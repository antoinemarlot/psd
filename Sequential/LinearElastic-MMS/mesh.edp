/*******************************************************************************
*									       *
* Date:	   21/02/2019							       *
* Type:    Module file							       *
* Comment: Load/build 2D mesh file. Interfaced mesher 'bmag' & 'netgen' can be *
*          used  for  geometry  and  mesh creation. Accepted  external formats * 
*          include GMSHs '.msh' & INRIAs  '.mesh'. The file contains functions * 
*	   to generate a square, cardinal, or a cubic-bezir mesh.	       *
*									       *
*******************************************************************************/

mesh Th; 				// FE mesh in 2D
int[int] Dlabel(1);			// Dirichlet BC labels
bool plotmesh=1;			// Plot mesh using ffglut


//==============================================================================
// -------Structural tetra square mesh function-------
//==============================================================================

// 	Note additionally the square mesh can be  converted to a rectangular one
// 	by controlling elongations ex and ey. nx and ny are nodes in x & y resp.
 
func int SqMesh(int nx, int ny, real ex, real ey){

  Th=square(nx,ny,[ex*x,ey*y]);		// Internal ff-bmag function square

  Dlabel.resize(4);			// Four labels for four sides
  Dlabel=[1,2,3,4];		     	// All four sides Dirichlet
}


//==============================================================================
// -------Unstructured tetra Cubic-Bezier curve mesh function-------
//==============================================================================

// 	The function will generate a irregular boundary mesh. The curve contains 
//      connecting two points with two control points, used to tune irregularity 
//      of the mesh.

func int CubBezierMesh(int nx){

  func real bzi(real p0, real p1, real q1, real q2, real t){
    return p0*(1-t)^3 + q1*3*(1-t)^2*t + q2*3*(1-t)*t^2 + p1*t^3;
  }

  real[int] p00 = [0, 1], p01 = [0, -1], q00 = [-2, 0.1], q01 = [-2, -0.5];
  real[int] p11 = [1,-0.9], q10 = [0.1, -0.95], q11=[0.5, -1];
  real[int] p21 = [2, 0.7], q20 = [3, -0.4], q21 = [4, 0.5];
  real[int] q30 = [0.5, 1.1], q31 = [1.5, 1.2];
    
  border G1(t=0, 1){
    x=bzi(p00[0], p01[0], q00[0], q01[0], t);
    y=bzi(p00[1], p01[1], q00[1], q01[1], t);
    label = 1;
  }	

  border G2(t=0, 1){
    x=bzi(p01[0], p11[0], q10[0], q11[0], t);
    y=bzi(p01[1], p11[1], q10[1], q11[1], t);
    label = 2;
  }
  	
  border G3(t=0, 1){
    x=bzi(p11[0], p21[0], q20[0], q21[0], t);
    y=bzi(p11[1], p21[1], q20[1], q21[1], t);
    label = 3;
  }

  border G4(t=0, 1){
    x=bzi(p21[0], p00[0], q30[0], q31[0], t);
    y=bzi(p21[1], p00[1], q30[1], q31[1], t);
    label = 4;
  }

  Th = buildmesh(G1(2*nx) + G2(nx) + G3(3*nx) + G4(nx));

  Dlabel.resize(4);			// Four labels for four sides
  Dlabel=[1,2,3,4];			// All four sides Dirichlet
  				    
}

//==============================================================================
// -------Unstructured tetra Cardinal curve mesh function-------
//==============================================================================

func int CardinalMesh(int nx){ 
  real b = 1.;
  real a = b;

  func real phix(real t){
    return (a+b)*cos(t) - b*cos(t*(a+b)/b);
  }

  func real phiy(real t){
    return (a+b)*sin(t) - b*sin(t*(a+b)/b);
  }

  border C(t=0, 2*pi){x=phix(t); y=phiy(t);label = 1;}

  Th = buildmesh(C(nx));
    
  Dlabel.resize(1);			// Single label required
  Dlabel=[1];				// Dirichlet border
}

//==============================================================================
// -------Unstructured tetra circle mesh function-------
//==============================================================================

func int CirMesh(int nx, real r){ 

  border a(t=0, 2*pi){x=r*cos(t); y=r*sin(t); label=1;}
  Th = buildmesh(a(nx));
  
  Dlabel.resize(1);			// Single label required
  Dlabel=[1];				// Dirichlet border
}  


//==============================================================================
// -------Building and plotting the mesh-------
//==============================================================================

//SqMesh(getARGV("-nx", 3),getARGV("-ny", 3),getARGV("-ex", .1),getARGV("-ey", .1));
//CardinalMesh(getARGV("-nx", 40));			// Call to CardinalMesh()
//CubBezierMesh(getARGV("-nx", 12));			// Call to CubBezierMesh()

CirMesh(getARGV("-nx", 50),getARGV("-r", 1.));		// Call to CirMesh()

//---Refining Mesh Via Split---//
int ss=getARGV("-s", 1);
Th = trunc(Th, 1, split=ss);


if(plotmesh)plot(Th);
