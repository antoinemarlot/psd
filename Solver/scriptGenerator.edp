/**************************************************************************************
*									       	      *
* Date:	   04/03/2019							              *
* Type:    Execution file						              *
* Comment: This main file generates three edp files: macros, parameters, varfmatsolve *
*          and meshPartitioning. Commandline arguments controls the nature of the ge- *
*          nerated file. One is advised to carefully go through these arguments.      *
* To run : ff-mpirun -np 1 main.edp -v 0 -ns -nw [ARGUMENTS]		              *
*									              *
**************************************************************************************/

//=====================================================================================
// ------ All command line argument descriptions [ARGUMENTS] ------
//=====================================================================================
/*
  -dimension   [int]	  Accepts values 2 or 3.  2 for 2D 3 for 3D. Default 2.
  
  -lagrange    [int]      Lagrange order used for building FE space. Options are 
  			  1 for P1 or 2 for P2. Defaut is P1.  
  
  -partitioner [sting]    Mesh partitioner to be used. Options are "metis"
  			  "parmetis" "scotch" or "ptstoch".
  			
  -partitioner parmetis   Mesh partitioner is parmetis. Additional option is 
  			  active '-parmetis_worker [int]'.			
  			  
  -help        [bool]     To activate helping message on the terminal. Default OFF. 			  
  			  
  -plot        [bool]     To activate plotting routine. Default OFF.
  
  -pointbc     [bool]     To activate Dirichlet boundry condition on point. Default OFF.
  
  -nonlinear   [bool]     To activate non-linear mechanics (Crack). Default OFF.
  
  -bodyforce   [bool]     To activate volumetric source term (body force). Default OFF.
  
  -dirichletbc [bool]     To activate Dirichlet boundary condition. Default ON.
  
  -tractionbc  [bool]     To activate traction boundary condition (Neumann).Default OFF. 

  -sequential  [bool]	  To generate a sequential ff++ solver. Default OFF.

*/

//=====================================================================================
// ------ All files to be included ------ 
//=====================================================================================

  include "getARGV.idp"    	// Enables importing commandline arguments

//=====================================================================================
// ------ All variables ------ 
//=====================================================================================

  int spc = getARGV("-dimension", 2);
  int lag = getARGV("-lagrange" , 1); 
  
  string Partitioner=getARGV("-partitioner", "parmetis");

  bool help        =  usedARGV("-help"       ) != -1;
  bool plotAll     =  usedARGV("-plot"       ) != -1;
  bool debug       =  usedARGV("-debug"      ) != -1;
  bool pointbc     =  usedARGV("-pointbc"    ) != -1;
  bool timelog     =  usedARGV("-timelog"    ) != -1;
  bool bodyforce   =  usedARGV("-bodyforce"  ) != -1;
  bool nonlinear   =  usedARGV("-nonlinear"  ) != -1;   
  bool tractionbc  =  usedARGV("-tractionbc" ) != -1; 
  bool Sequential  =  usedARGV("-sequential" ) != -1;      
  bool dirichletbc =  usedARGV("-dirichletbc") !=  1;

//=====================================================================================   
// ------ Help message on the screen ------ 
//=====================================================================================

if(help){cout
<<"										   \n"
<<"================================================================================\n"
<<"                       ----YOU ACTIVATED THE HELP OPTION----			   \n"
<<"                      Please read the messages below carefully		   \n"
<<"================================================================================\n"
<<"										   \n"
<<"										   \n"
<<" According to the flags provided You are solving A "+spc+"D problem.		   \n"
<<"										   \n"
<<"										   \n"
<<"  # With"<<(bodyforce   ? "" : "out")<<" bodyforce acting on the volume.	   \n"
<<"  # With"<<(tractionbc  ? "" : "out")<<" traction boundary condition.   	   \n"
<<"  # With"<<(dirichletbc ? "" : "out")<<" Dirichlet surface boundary condition.  \n"
<<"  # With"<<(pointbc     ? "" : "out")<<" Dirichlet point boundary condition.    \n"
<<"  # Paraview plotting is "<<(plotAll ? "en" : "dis")<<"abled.		   \n"
<<"										   \n"
<<"										   \n"
<<" WARNING If something doesn't look right consider rerunning with correct flags. \n"
<<"										   \n" 
<<"										   \n"
<<"/***********************************IMPORTANT***********************************\n"
<<"*                                                                              *\n"
<<"* To change the mesh and the material parameters edit 'parameters.edp'         *\n"
<<"*                                                                              *\n"
<<"* 1. Edit  <<ThName>> the [string] name of your mesh  file  with  location. By *\n"
<<"*    default it is ThName= <<../Meshes/2D/Meshes/bar2D>> .                     *\n"
<<"*                                                                              *\n"
<<"* 2. Edit <<E,nu,f1,f2,f3>>  of [real] type representing the materials modulus *\n"
<<"*    of elasticity, poissions ratio, body forces f1,f2,f3 in x,y,z directions. *\n"
<<"*                                                                              *\n"
<<"*******************************************************************************/\n"
<<"										   \n";

if(dirichletbc)cout 
<<"										   \n"
<<"/***********************************IMPORTANT***********************************\n"
<<"*                                                                              *\n"
<<"* Using Dirichlet BC  please edit the file 'varfmatsolve.edp'                  *\n"
<<"*                                                                              *\n"
<<"* 1. Edit  <<Dlabel>> i.e. the  [int]   vector   of  labels  that contain your *\n"
<<"*    Dirichlet border. So  if your border is labeled 1 Dlabel=[1], if you have *\n"
<<"*    two Dirichlet borders 4 & 5 then  Dlabel = [4,5].                         *\n"
<<"*                                                                              *\n"
<<"* 2. Edit <<Dvalue>> i.e the [real] vector defined by Dirichlet  values.  Each *\n"
<<"*    Dirichlet borders  will need  Dirichlet field values. So e.g.  Dlabel=[1] *\n"
<<"*    you can use Dvalue=[1.,0.], meaning u1=1, and u2=0                        *\n"
<<"*                                                                              *\n"
<<"*******************************************************************************/\n"
<<"										   \n";

if(bodyforce)cout
<<"										   \n"
<<"/***********************************IMPORTANT***********************************\n"
<<"*                                                                              *\n"
<<"* Using bodyforce within the problem please edit the file 'varfmatsolve.edp'   *\n"
<<"*                                                                              *\n"
<<"* 1. Edit macro <<BF>> and  provide three components of  bodyforce. Note  that *\n"
<<"*    the macro accepts real or functional values.                              *\n" 
<<"*                                                                              *\n"
<<"*******************************************************************************/\n"
<<"										   \n";

if(pointbc)cout
<<"										   \n"
<<"/***********************************IMPORTANT***********************************\n"
<<"*                                                                              *\n"
<<"* Using Dirichlet BC on  point please edit the file 'varfmatsolve.edp'         *\n"
<<"*                                                                              *\n"
<<"* 1. Edit <<Dpointlab>> i.e. the  [int]   vector of  labels  that contain your *\n"
<<"*    Dirichlet Point. So if your point is on line 4 Dpointlab = [4].           *\n"
<<"*                                                                              *\n"
<<"* 2. Edit <<PnV>> i.e  the [real] vector defined by  [x,y,u1,u2]. Here (x,y) & *\n"
<<"*    (u1,u2) are coordinates and deformation values of the Dirichlet point.    *\n"
<<"*                                                                              *\n"
<<"*******************************************************************************/\n"
<<"										   \n";

if(tractionbc)
cout 
<<"										   \n"
<<"/***********************************IMPORTANT***********************************\n"
<<"*                                                                              *\n"
<<"* Using Neumann BC  please edit the file 'varfmatsolve.edp'                    *\n"
<<"*                                                                              *\n"
<<"* 1. Edit <<Tlabel>>  i.e. the  [int]   vector   of  labels  that contain your *\n"
<<"*    traction border. So  if your borders is labeled 1 Tlabel=[1], if you have *\n"
<<"*    two traction borders 4 & 5 then  Tlabel = [4,5].                          *\n"
<<"*                                                                              *\n"
<<"* 1. Edit macro <<T>> & provide three components of  traction on the boundary. *\n"
<<"*                                                                              *\n"
<<"*******************************************************************************/\n"
<<"										   \n";

} //-- [if loop terminator] help ended --//

//=====================================================================================
// ------ Building the main.edp file ------ 
//=====================================================================================

{ofstream  writemain("main.edp");

writemain
<<"										   \n"
<<"/**********************************Main file************************************\n"
<<"*                                                                              *\n"
<<"* Note!!! This file is  generated  by running scriptGenerator.edp. Do not edit *\n"
<<"*         in order to  control this  file please change flag arguments of  the *\n"
<<"*         scriptGenerator, details of which are present in scriptGenerator.edp *\n"
<<"*         or in the README.MD file.                                            *\n"
<<"*                                                                              *\n"
<<"*******************************************************************************/\n"
<<"										   \n"
<<"										   \n"
<<"//==============================================================================\n"
<<"// ------ Module files load and include ------ 				   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"										   \n";

if(Sequential)writemain
<<"										   \n"
<<" include \"getARGV.idp\"\t		// Enables commandline arguments	   \n"
<<" include \"parameters.edp\"\t  	// Control parameters, propeties, etc..    \n"
<<" include \"macros.edp\"\t		// User-defined macro file	 	   \n"
<<" include \"mesh.edp\"      	 	// Loading mesh 	   		   \n"
<<" include \"varfmatsolve.edp\"       	// Varf. and x=A^-1*b	   		   \n"    
<<"										   \n";

if(!Sequential)writemain
<<"										   \n"
<<" load    \"PETSc\"			// PETSc plugin activated		   \n"
<<" include \"getARGV.idp\"\t		// Enables commandline arguments	   \n"
<<" include \"parameters.edp\"\t  	// Control parameters, propeties, etc..    \n"
<<" include \"macros.edp\"\t		// User-defined macro file	 	   \n"
<<" include \"../Plugins/DDmacro.edp\"	// Domain decomposition macros 	  	   \n"
<<" include \"meshPartitioning.edp\"  	// Loading mesh 	   		   \n"
<<" include \"varfmatsolve.edp\"       	// Varf. and x=A^-1*b	   		   \n"    
<<"										   \n";

} //-- [ostream terminator]  main.edp closed --//


//=====================================================================================
// ------ Building the macros.edp file ------ 
//=====================================================================================
   
{ofstream  writemacros("macros.edp");

writemacros
<<"										   \n"
<<"/******************************Userdefined macros*******************************\n"
<<"*                                                                              *\n"
<<"* Note!!! This file is  generated  by running scriptGenerator.edp. Do not edit *\n"
<<"*         in order to  control this  file please change flag arguments of  the *\n"
<<"*         scriptGenerator, details of which are present in scriptGenerator.edp *\n"
<<"*         or in the README.MD file.                                            *\n"
<<"*                                                                              *\n"
<<"*******************************************************************************/\n"
<<"										   \n";
  

if(spc==2){writemacros
<<"										   \n"
<<"//--------------------Macros needed by DDmacro.idp----------------------------//\n"
<<"										   \n"
<<"  macro partitioner "+Partitioner+"\t\t	// Mesh partitioner used   	   \n"
<<"  macro dimension 2      			// Two-dimensional problem 	   \n"
<<"  macro Pk [P"+lag+",P"+lag+"]\t\t		// Finite element space	   	   \n";

if(!nonlinear)writemacros
<<"										   \n"
<<"  macro def  (i) [ i , i#1 ]			// Vect. field definition  	   \n"
<<"  macro init (i) [ i ,  i  ]			// Vect. field initialize  	   \n"
<<"										   \n";

writemacros
<<"										   \n"
<<"//--------------------Divergence and epsilion macros--------------------------//\n"
<<"										   \n"
<<"  macro divergence(i)(dx(i) + dy(i#1))		// Divergence function     \n"
<<"  macro epsilon(i) [dx(i), dy(i#1),						   \n" 
<<"                   (dy(i)+dx(i#1))/sqrt(2.0)]	// Strain definition	   \n";

if(nonlinear)writemacros
<<"										   \n"
<<"//---------------------------Non-linear macros--------------------------------//\n"
<<"										   \n"
<<"  macro def2  (i) [ i , i#1 ]				// Vect. field 	   \n"
<<"  macro init2 (i) [ i ,  i  ]				// Vect. initialize\n"
<<"  macro def  (i)   i						// Scalar field    \n"
<<"  macro init (i)   i						// Initialize  	   \n"
<<"  macro Zk         P1             				// FE space	   \n"
<<"  macro grad (i) [ dx(i), dy(i) ]				// 2d gradient     \n"
<<"  macro sxx  (i) ( lambda*divergence(i) + 2*mu*dx( i ) )	// Sigma_xx	   \n"
<<"  macro syy  (i) ( lambda*divergence(i) + 2*mu*dy(i#1) )	// Sigma_yy	   \n"
<<"  macro sxy  (i) ( mu*( dy(i) + dx(i#1) ) )			// Sigma_yx	   \n"
<<"  macro sig  (i) [ sxx(i), syy(i), 2*sqrt(2.0)*sxy(i) ] 	// Sigma	   \n"
<<"  macro Hplus(i) (0.5*(sig(i)'*epsilon(i)))			// Hplus   	   \n"
<<"										   \n";
   
  
if(Sequential)writemacros
<<"										   \n"
<<"//--------------------Sequential remapping macros-----------------------------//\n"
<<"										   \n"
<<"  macro meshN()mesh				// Two-dimensional problem	   \n"
<<"  macro intN()int2d				// Two-dimensional integral	   \n"
<<"  macro intN1()int1d				// One-dimensional integral	   \n"
<<"  macro readmeshN()readmesh			// Two-dimensional 'mesh' reader   \n"
<<"  macro gmshloadN()gmshload			// Two-dimensional 'msh' reader	   \n"
<<"										   \n";

} //-- [if loop terminator] space==2 ended --//



if(spc==3){writemacros
<<"										   \n"
<<"//--------------------Macros needed by DDmacro.idp----------------------------//\n"
<<"										   \n"
<<"  macro Pk [P"+lag+",P"+lag+",P"+lag+"]\t\t		// Finite element space	   \n"
<<"  macro partitioner "+Partitioner+"\t		// Mesh partitioner used   \n"
<<"  macro dimension   3				// Three-D problem	   \n";


if(!nonlinear)writemacros
<<"										   \n"
<<"  macro init(i) [i,   i,   i]			// Vect. field initialize  \n"
<<"  macro def(i)  [i, i#1, i#2]			// Vect. field definition  \n"
<<"										   \n";

writemacros
<<"										   \n"
<<"//--------------------Divergence and epsilion macros--------------------------//\n"
<<"										   \n"
<<"  macro divergence(i) (dx(i)+dy(i#1)+dz(i#2))	// Divergence function	   \n"
<<"  macro epsilon(i) [dx(i), dy(i#1), dz(i#2),					   \n"
<<"                   (dz(i#1)+dy(i#2))/sqrt(2.0),				   \n"
<<"                   (dz(i) + dx(i#2))/sqrt(2.0),				   \n"
<<"                   (dy(i) + dx(i#1))/sqrt(2.0)]	// Strain definition	   \n"
<<"										   \n";

if(nonlinear)writemacros
<<"										   \n"
<<"//--------------------------Non-linear macros---------------------------------//\n"
<<"										   \n"
<<"  macro init2(i) [i,   i,   i]			// Vect. field initialize  \n"
<<"  macro def2(i)  [i, i#1, i#2]			// Vect. field definition  \n"
<<"  macro def  (i)   i						// Scalar field    \n"
<<"  macro init (i)   i						// Initialize  	   \n"
<<"  macro Zk         P1             				// FE space	   \n"
<<"  macro grad(i)[dx(i), dy(i), dz(i)]			// Three-D gradient	   \n"
<<"  macro sxx(i)( lambda*divergence(i)+2*mu*dx(i) )	// Sigma_xx		   \n"
<<"  macro syy(i)(lambda*divergence(i)+2*mu*dy(i#1))	// Sigma_yy		   \n"
<<"  macro szz(i)(lambda*divergence(i)+2*mu*dz(i#2))	// Sigma_zz		   \n"
<<"										   \n";

if(Sequential)writemacros
<<"										   \n"
<<"//---------------------Sequential remapping macros----------------------------//\n"
<<"										   \n"
<<"  load \"msh3\"				// Loading 3D mesh		   \n"
<<"  macro meshN()mesh3				// Three-dimensional problem	   \n"
<<"  macro intN()int3d				// Three-dimensional integral	   \n"
<<"  macro intN1()int2d				// Two-dimensional integral	   \n"
<<"  macro readmeshN()readmesh3			// Three-dimensional problem	   \n"
<<"  macro gmshloadN()gmshload3			// Three-dimensional 'msh' reader  \n"
<<"										   \n";

} //-- [if loop terminator] space==3 ended --//



if(pointbc){writemacros
<<"										   \n"
<<"//----------------------------Point BC macro----------------------------------//\n"
<<"										   \n"
<<"  macro Pointbc(Dpointlab,Wh,A,b,PnV){					   \n"
<<"    int count=0;								   \n"
<<"    meshN Th=Wh.Th;								   \n"
<<"										   \n";
 
if(spc==2)writemacros
<<"										   \n"
<<"	varf vlabs(def(u),def(v)) 						   \n"
<<"	= on( Dpointlab, 							   \n"
<<"		u  = -1*( x==PnV[0] && y==PnV[1] ),   				   \n"
<<"		u1 = -1*( x==PnV[0] && y==PnV[1] )				   \n"
<<"	     );									   \n"
<<"										   \n";

if(spc==3)
writemacros
<<"										   \n"
<<"    varf vlabs(def(u),def(v)) 						   \n"
<<"	= on( Dpointlab, 							   \n"
<<"		u  = -1*( x==PnV[0] && y==PnV[1] && z==PnV[2] ),	  	   \n"
<<"		u1 = -1*( x==PnV[0] && y==PnV[1] && z==PnV[2] ),	   	   \n"
<<"		u2 = -1*( x==PnV[0] && y==PnV[1] && z==PnV[2] ) 	   	   \n"
<<"	    );									   \n"
<<"										   \n";

writemacros
<<"										   \n"
<<"    real[int] absc=vlabs(0,Wh);						   \n"
<<"										   \n"
<<"    for (int i=0; i<Wh.ndof; i++){						   \n"
<<"      if(abs(-1e+30-absc(i))==0 ){						   \n"
<<"        A(i,i)=tgv;								   \n"
<<"        b[i]=PnV["+spc+"+count]*tgv;						   \n"
<<"        count++;								   \n"
<<"         if(count=="+spc+") break;						   \n"
<<"      }									   \n"
<<"    }									   \n"
<<"  }										   \n"
<<"										   \n"
<<"										   \n";

} //-- [if loop terminator] pointbc ended --//


if(timelog){writemacros
<<"										   \n"
<<"//-----------------------------------Timing macros----------------------------//\n"
<<"										   \n";

if(!Sequential)writemacros
<<"										   \n"
<<"  macro MPItimerbegin(str1,t0){						   \n"
<<"      mpiBarrier(mpiCommWorld);						   \n"
<<"      t0 = mpiWtime();							   \n"
<<"      if(mpirank==0)								   \n"
<<"      cout << \"\"+str1+\" began\\n\";					   \n"
<<"  }//									   \n"
<<"										   \n"
<<"  macro MPItimerend(str1,t0){						   \n"
<<"      mpiBarrier(mpiCommWorld);						   \n"
<<"      if(mpirank==0)								   \n"
<<"      cout.scientific << \"It took [ \"<< mpiWtime()-t0 			   \n"
<<"           << \" ] seconds to finish \" +str1+\"\\n\\n\";			   \n"
<<"  }//									   \n"
<<"										   \n"
<<"										   \n";

if(Sequential)writemacros
<<"										   \n"
<<"  macro timerbegin(str1,t0){							   \n"
<<"      t0 = clock();								   \n"
<<"      cout << \"\"+str1+\" began\\n\";					   \n"
<<"  }//									   \n"
<<"										   \n"
<<"  macro timerend(str1,t0){							   \n"
<<"      cout.scientific << \"It took [ \"<< clock()-t0 			   \n"
<<"           << \" ] seconds to finish \" +str1+\"\\n\\n\";			   \n"
<<"  }//									   \n"
<<"										   \n"
<<"										   \n";

} //-- [if loop terminator] timelog ended --//

} //-- [ostream terminator]  macros.edp closed --//  


//=====================================================================================
// ------ Building the parameters.edp file ------ 
//=====================================================================================

{ofstream  writemeshParameters("parameters.edp");

writemeshParameters
<<"										   \n"
<<"/***********************************Parameters**********************************\n"
<<"*                                                                              *\n"
<<"* Note!!! This file is  generated  by running scriptGenerator.edp. Do not edit *\n"
<<"*         in order to  control this  file please change flag arguments of  the *\n"
<<"*         scriptGenerator, details of which are present in scriptGenerator.edp *\n"
<<"*         or in the README.MD file.                                            *\n"
<<"*                                                                              *\n"
<<"*******************************************************************************/\n"
<<"										   \n"
<<"										   \n"
<<"										   \n"
<<"//==============================================================================\n"
<<"// -------FEM mesh to be loaded (Un-partitioned)------- 			   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"										   \n"
<<"string ThName = \"../Meshes/"+spc+"D/Meshes/bar"+spc+"D\";  	// Mesh file name  \n"
<<"										   \n"
<<"										   \n"
<<"//==============================================================================\n"
<<"// -------Material properties------- 		 			   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"										   \n"
<<"										   \n"
<<"real mu,lambda"<<(timelog ? ",t0" : "")<<" "<<(bodyforce ? ",f2" : "")<<";	   \n"
<<"{										   \n"
<<"real E  = 200.e9,				//Modulus of Elasticity - [Pa]	   \n"
<<"     nu = 0.3  ;				// Poisson ratio - [-]		   \n"
<<"	 									   \n"
<<"mu     = E/(2.*(1.+nu));							   \n"
<<"lambda = E*nu/((1.+nu)*(1.-2.*nu));						   \n"
<<"	 									   \n"
<<(bodyforce ? "f2 = 8.e3*(-9.81);				// Rho*g" : "")<<" \n"
<<"	 									   \n"
<<"}	 									   \n"
<<"	 									   \n"
<<"	 									   \n";

if(nonlinear)writemeshParameters
<<"	 									   \n"
<<"//==============================================================================\n"
<<"// -------Nonlinear parameters------- 		 			   \n"
<<"//==============================================================================\n"
<<"	 									   \n"
<<"real Gc =2.7,								   \n"
<<"	lo,									   \n"
<<"	lfac=2,									   \n"
<<"	maxtr = 1e-3,								   \n"
<<"	tr = 1e-5,								   \n"
<<"	dtr = 1e-5;								   \n"
<<"	 									   \n";

} //-- [ostream terminator]  parameters.edp closed --//


//=====================================================================================
// ------ Building the meshPartitioning.edp file ------ 
//=====================================================================================
  
{ofstream  writemeshPartitioning(Sequential ? "mesh.edp" : "meshPartitioning.edp" );

writemeshPartitioning
<<"										   \n"
<<"/*****************************Mesh And Partitioning*****************************\n"
<<"*                                                                              *\n"
<<"* Note!!! This file is  generated  by running scriptGenerator.edp. Do not edit *\n"
<<"*         in order to  control this  file please change flag arguments of  the *\n"
<<"*         scriptGenerator, details of which are present in scriptGenerator.edp *\n"
<<"*         or in the README.MD file.                                            *\n"
<<"*                                                                              *\n"
<<"*******************************************************************************/\n"
<<"										   \n"
<<"										   \n";

//-----------------------------SEQUENTIAL------------------------------------------//

if(Sequential){writemeshPartitioning
<<"										   \n"
<<"										   \n"
<<"//==============================================================================\n"
<<"// -------Loading the FE mesh-------  					   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"										   \n"
<<(timelog ? "	timerbegin(\"Mesh Loading\",t0)\n" : " "         	  	    )
<<" 		load \"gmsh\"					// Load  gmsh	   \n"
<<" 		meshN Th = gmshloadN(\"\"+ThName+\".msh\");\t	// Mesh loaded	   \n"
<<(timelog ? "	timerend  (\"Mesh Loading\",t0)\n" : " "     		      	    )
<<"										   \n"
<<"										   \n"
<<"//==============================================================================\n"
<<"// -------Building the FE spaces-------  					   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"										   \n"
<<" fespace Vh   ( Th , Pk );			// Mixed FE space (displacemnt)	   \n"
<<"	    Vh<real> def(u);			// Defining LHS			   \n"
<<"										   \n";

if(nonlinear)writemeshPartitioning
<<"										   \n"
<<" fespace Vh1  ( Th , Zk );			// Damage field	FE space	   \n"
<<"										   \n";

}

//-------------------------------PARALLEL------------------------------------------//

if(!Sequential){writemeshPartitioning
<<"										   \n"
<<"										   \n"
<<"//==============================================================================\n"
<<"// -------Loading the FE mesh-------  					   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"										   \n"
<<" meshN   Th = DummyMesh;			// This is a dummy mesh for now	   \n"
<<"										   \n"
<<"										   \n"
<<"//==============================================================================\n"
<<"// -------Building the FE spaces-------  					   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"										   \n";

writemeshPartitioning
<<"										   \n"
<<" fespace Vh   ( Th , Pk );			// Local mixed FE space		   \n"
<<"										   \n";

if(nonlinear)writemeshPartitioning
<<"										   \n"
<<" fespace Vh1  ( Th , Zk );			// Damage field	FE space	   \n"
<<"										   \n";

writemeshPartitioning
<<"										   \n"
<<"//==============================================================================\n"
<<"// -------Domian decomposition suppoprt-------  				   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"										   \n";

writemeshPartitioning
<<"										   \n"
<<" int[int] arrayIntersectionP;                // Ranks of neighboring subdomains \n"
<<" int[int][int] restrictionIntersectionP(0);  // Local-to-neighbors renumbering  \n"
<<" real[int] DP;                               // Partition of unity		   \n"
<<"										   \n"
<<"										   \n";

if(nonlinear)writemeshPartitioning
<<"										   \n"
<<" int[int] arrayIntersectionZ;                // Ranks of neighboring subdomains \n"
<<" int[int][int] restrictionIntersectionZ(0);  // Local-to-neighbors renumbering  \n"
<<" real[int] DZ;                               // Partition of unity		   \n"
<<"										   \n"
<<"										   \n";

writemeshPartitioning
<<"										   \n"
<<"//==============================================================================\n"
<<"// -------Function building the restriction matrix and partion of unity-------  \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"										   \n"
<<" func int PartThAndBuildCommunication(){					   \n"
<<"										   \n"
<<"  load \"gmsh\"                                      // Load meshes from gmsh   \n"
<<"  meshN ThGlobal = gmshloadN(\"\"+ThName+\".msh\");    // Global mesh loaded	   \n"
<<"										   \n"
<<"										   \n";

if(!nonlinear)writemeshPartitioning
<<"										   \n"
<<"  PETScMPIBuild(								   \n"
<<"		   Th				, // Local  mesh		   \n"
<<"		   ThGlobal			, // Global mesh		   \n"
<<"		   getARGV( \"-split\" , 1 )	, // Split factor		   \n"
<<"		   DP				, // Partition of unity	   	   \n"
<<"		   arrayIntersectionP		, // Neighbour ranks	   	   \n"
<<"		   restrictionIntersectionP	, // Restriction matrix	   	   \n"
<<"		   Vh				, // Local FE space name	   \n"
<<"		   Pk				, // Vectorial FE space	   	   \n"
<<"		   mpiCommWorld			  // MPI world		   	   \n"
<<"		  )		   						   \n"
<<"										   \n";

if(nonlinear)writemeshPartitioning
<<"										   \n"
<<"  fespace Ph(ThGlobal, P0);							   \n"
<<"  	     Ph part;								   \n"
<<"										   \n"
<<"										   \n"
<<"  if(mpirank == 0)								   \n"
<<"	partitionerSeq(part[], ThGlobal, mpisize);				   \n"
<<"										   \n"
<<"  partitionerPar(part[], ThGlobal, mpiCommWorld, mpisize);			   \n"
<<"										   \n"
<<"  PETScMPIBuildWithPartitioning(						   \n"
<<"		   Th				, // Local  mesh		   \n"
<<"		   ThGlobal			, // Global mesh		   \n"
<<"		   part[]			, // Partitions			   \n"
<<"		   getARGV( \"-split\" , 1 )	, // Split factor		   \n"
<<"		   DZ				, // Partition of unity	   	   \n"
<<"		   arrayIntersectionZ		, // Neighbour ranks	   	   \n"
<<"		   restrictionIntersectionZ	, // Restriction matrix	   	   \n"
<<"		   Vh1				, // Local FE space name	   \n"
<<"		   Zk				, // Vectorial FE space	   	   \n"
<<"		   mpiCommWorld			  // MPI world		   	   \n"
<<"		  )		   						   \n"
<<"										   \n"
<<"  ThGlobal = gmshloadN(\"\"+ThName+\".msh\");    // Global mesh re-loaded	   \n"
<<"										   \n"
<<"  PETScMPIBuildEdgeWithPartitioning(						   \n"
<<"		   Th				, // Local  mesh		   \n"
<<"		   ThGlobal			, // Global mesh		   \n"
<<"		   part[]			, // Partitions			   \n"
<<"		   getARGV( \"-split\" , 1 )	, // Split factor		   \n"
<<"		   DP				, // Partition of unity	   	   \n"
<<"		   arrayIntersectionP		, // Neighbour ranks	   	   \n"
<<"		   restrictionIntersectionP	, // Restriction matrix	   	   \n"
<<"		   Vh				, // Local FE space name	   \n"
<<"		   Pk				, // Vectorial FE space	   	   \n"
<<"		   mpiCommWorld			, // MPI world		   	   \n"
<<"		   Pk				, // Vectorial FE space	   	   \n"
<<"		   def2				, // Scalar definition	   	   \n"
<<"		   init2		  	  // Scalar initilization   	   \n"
<<"		  )		   						   \n"
<<"										   \n"
<<"										   \n"
<<"										   \n"
<<"										   \n";

writemeshPartitioning
<<"										   \n"
<<"  return 0;									   \n"
<<"										   \n"
<<" }										   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"Mesh Partitioning\",t0)\n" : " "           	    )
<<"    PartThAndBuildCommunication();						   \n"
<<(timelog ? "	MPItimerend(\"Mesh Partitioning\",t0)\n" : " "           	    )
<<"										   \n"
<<"										   \n";

}

} //-- [ostream terminator]  meshpartitioning.edp closed --//


//=====================================================================================
// ------ Building the varfmatsolve.edp file ------ 
//=====================================================================================

{ofstream  writevarfmatsolve("varfmatsolve.edp");

writevarfmatsolve
<<"										   \n"
<<"/**************Variational formulation, solving, & post-proc *******************\n"
<<"*                                                                              *\n"
<<"* Note!!! This file is  generated  by running scriptGenerator.edp. Do not edit *\n"
<<"*         in order to  control this  file please change flag arguments of  the *\n"
<<"*         scriptGenerator, details of which are present in scriptGenerator.edp *\n"
<<"*         or in the README.MD file.                                            *\n"
<<"*                                                                              *\n"
<<"*******************************************************************************/\n"
<<"										   \n"
<<"										   \n"
<<"//==============================================================================\n"
<<"// -------Dirichlet and Neumann conditions-------				   \n"
<<"//==============================================================================\n"
<<"										   \n";

if(dirichletbc){writevarfmatsolve
<<"										   \n"
<<"//---Surface---//								   \n"
<<"int [int]   Dlabel = [2];		// Vector containing Dirichlet labels 	   \n"
<<"										   \n";

if(spc==2)writevarfmatsolve
<<"										   \n"
<<"real[int]   Dvalue =[0.,0.];		// Vector containing Dirichlet values	   \n"
<<"										   \n";

if(spc==3)writevarfmatsolve
<<"										   \n"
<<"real[int]   Dvalue=[0.,0.,0.];	// Vector containing Dirichlet values	   \n" 
<<"										   \n";

}  //-- [if loop terminator] dirichletbc ended --//

if(pointbc)writevarfmatsolve
<<"										   \n"
<<"//---Point---//								   \n"
<<"int [int]   Dpointlab=[2];		// Vector containing Dirichlet labels	   \n"
<<"real[int]   PnV=[0., 0., 0., 0.];	// [x, y, u1, u2]			   \n"
<<"										   \n";

if(bodyforce){writevarfmatsolve
<<"										   \n"
<<"//---Body force---//								   \n";

if(spc==2)writevarfmatsolve
<<"										   \n"
<<"macro BF [0,f2]			// Two component body forces	   	   \n"; 

if(spc==3)writevarfmatsolve
<<"										   \n"
<<"macro BF [0,f2,0]			// Three component body forces	   	   \n"; 
      
}  //-- [if loop terminator] bodyforce ended --//

if(tractionbc){writevarfmatsolve
<<"										   \n"
<<"//---Neumann---//								   \n"
<<"int [int]   Tlabel=[2];		// Vector containing Neumann labels	   \n";

if(spc==2)writevarfmatsolve
<<"macro T [0,1]			// Two component traction forces	   \n"; 

if(spc==3)writevarfmatsolve
<<"macro T [0,1,0]			// Three component traction forces	   \n"; 

}   //-- [if loop terminator] tractionbc ended --//

if(!nonlinear){writevarfmatsolve
<<"										   \n"
<<"//==============================================================================\n"
<<"// -------Variation formulation linear-------				   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"										   \n";

writevarfmatsolve
<<"										   \n"
<<"varf elast(def(u),def(v))							   \n"
<<"	= intN(Th,qforder=3)(							   \n"
<<"			lambda*divergence(u)*divergence(v)			   \n"
<<"			+2.*mu*( epsilon(u)'*epsilon(v) )			   \n"
<<"		  )								   \n";

if(bodyforce)writevarfmatsolve
<<"										   \n"
<<"	+ intN(Th,qforder=2)(BF'*def(v))	// Body force   (volumetric)	   \n";


if(tractionbc)writevarfmatsolve
<<"										   \n"
<<"	+ intN1(Th,Tlabel,qforder=2)(T'*def(v))	// Traction force (Neumann BC)	   \n";

if(dirichletbc){

if(spc==2)writevarfmatsolve
<<"										   \n"
<<"	+ on( Dlabel, 				// Displacement (Dirichlet)	   \n"
<<"		u  = Dvalue[0],							   \n"
<<"		u1 = Dvalue[1]							   \n"
<<"	    );		   		   		   			   \n"
<<"										   \n";

if(spc==3)writevarfmatsolve
<<"										   \n"
<<"	+ on(Dlabel,				// Displacement (Dirichlet)	   \n"
<<"		u  = Dvalue[0],							   \n"
<<"		u1 = Dvalue[1],							   \n"
<<"		u2 = Dvalue[2]			   				   \n"
<<"	    );		   							   \n"
<<"										   \n";

}  //-- [if loop terminator] dirichletbc ended --//

}  //-- [if loop terminator] !nonlinear ended --//

if(nonlinear){writevarfmatsolve
<<"										   \n"
<<"//==============================================================================\n"
<<"// -------Variation formulation nonlinear-------				   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"										   \n"
<<"Vh<real>  def2(u), def2(uold);		// Defining displacement variables \n"
<<"										   \n"
<<"Vh1<real> phi,phiold;			// Damage field			   \n"
<<"										   \n"
<<"										   \n"
<<"										   \n"
<<"varf elast(def2(u),def2(v))							   \n"
<<"	= intN(Th,qforder=3)(							   \n"
<<"			((1 - phiold)*(1 - phiold) + 1e-6)*			   \n"
<<"			(lambda*divergence(u)*divergence(v)			   \n"
<<"			+2.*mu*( epsilon(u)'*epsilon(v) ))			   \n"
<<"			    )							   \n";

if(bodyforce)writevarfmatsolve
<<"	+ intN(Th,qforder=2)(BF'*def2(v))	// Body force   (volumetric)	   \n";

if(tractionbc)writevarfmatsolve
<<"	+ intN1(Th,Tlabel,qforder=2)(T'*def2(v))// Traction force (Neumann BC)	   \n";

if(dirichletbc){

if(spc==2)writevarfmatsolve
<<"	+ on(Dlabel,u=Dvalue[0],u1=Dvalue[1]);	// Displacement (Dirichlet)	   \n"
<<"										   \n";

if(spc==3)writevarfmatsolve
<<"	+ on(Dlabel,u=Dvalue[0],u1=Dvalue[1]					   \n"
<<"				,u2=Dvalue[2]);	// Displacement (Dirichlet)	   \n"
<<"										   \n";

}  //-- [if loop terminator] dirichletbc ended --//

writevarfmatsolve
<<"										   \n"
<<"varf phase(phi,q)								   \n"
<<"	= intN(Th,qforder=3)(							   \n"
<<"			(Gc*lo*(grad(phi)'*grad(q))) +				   \n"
<<"			( ((Gc/lo)  + 2.*Hplus(u))*phi*q )			   \n"
<<"			    )							   \n"
<<"	+ intN(Th,qforder=2)(  2.*Hplus(u)*q  )					   \n"
<<"	+ on(4,phi=1);				// Already Cracked (Dirichlet)     \n";

}  //-- [if loop terminator] nonlinear ended --//

if(nonlinear){writevarfmatsolve
<<"										   \n"
<<"//==============================================================================\n"
<<"// -------Nonlinear parameter calulations-------				   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"										   \n";

if(Sequential)writevarfmatsolve
<<"										   \n"
<<"{										   \n"
<<" fespace Vh0(Th,P0);								   \n"
<<" Vh0 size1=hTriangle;							   \n"
<<" lo=size1[].min;								   \n"
<<" lo=lo*lfac;									   \n"
<<"}										   \n"
<<"										   \n";

if(!Sequential)writevarfmatsolve
<<"										   \n"
<<"{										   \n"
<<" real himlocal,himGlobal;							   \n"
<<" fespace Vh0(Th,P0);								   \n"
<<" Vh0 size1=hTriangle;							   \n"
<<" himlocal=size1[].min;							   \n"
<<"										   \n"
<<" mpiAllReduce(himlocal,himGlobal,mpiCommWorld,mpiMIN);			   \n"
<<"										   \n"
<<" lo=himGlobal*lfac;								   \n"
<<"}										   \n"
<<"										   \n";

if(Sequential){writevarfmatsolve
<<"										   \n"
<<"										   \n"
<<"//==============================================================================\n"
<<"// -------Nonlinear loop-------						   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"while (tr <= maxtr){								   \n"
<<"										   \n"
<<"	cout <<  \"  Applied traction \" << tr <<endl;				   \n"
<<"										   \n"
<<"	if (tr >=5e-3)								   \n"
<<"		dtr = 1e-5;							   \n"
<<"										   \n"
<<"	for(int iter=0; iter<500; iter++){					   \n"

<<(timelog ? "	timerbegin(\"Matrix Assembly U\",t0)\n" : " "           	    )
<<"			matrix<real> A = elast(Vh,Vh);		// Assembly for A   \n"
<<(timelog ? "	timerend  (\"Matrix Assembly U\",t0)\n" : " "           	    )
<<(timelog ? "	timerbegin(\"RHS Assembly U\",t0)\n" : " " 	          	    )
<<"			real[int]    b = elast(0,Vh);		// Assembly for b   \n"
<<(timelog ? "	timerend  (\"RHS Assembly U\",t0)\n" : " "  	         	    )
<<(timelog ? "	timerbegin(\"Solving U\",t0)\n" : " " 	        	  	    )
<<"			set(A,solver=CG);			// Solver setup	   \n"
<<"			u[]=A^-1*b;				// Solve	   \n"
<<(timelog ? "	timerend  (\"Solving U\",t0)\n" : " " 	        	  	    )
<<"										   \n"
<<"										   \n"
<<(timelog ? "	timerbegin(\"Matrix Assembly PHI\",t0)\n" : " "           	    )
<<"			matrix<real> A1 = phase(Vh1,Vh1);	// Assembly for A   \n"
<<(timelog ? "	timerend  (\"Matrix Assembly PHI\",t0)\n" : " "           	    )
<<(timelog ? "	timerbegin(\"RHS Assembly PHI\",t0)\n" : " " 	          	    )
<<"			real[int]    b1 = phase(0,Vh1);		// Assembly for b   \n"
<<(timelog ? "	timerend  (\"RHS Assembly U\",t0)\n" : " "  	         	    )
<<(timelog ? "	timerbegin(\"Solving U\",t0)\n" : " " 	        	  	    )
<<"			set(A1,solver=CG);			// Solver setup	   \n"
<<"			phi[]=A1^-1*b1;				// Solve	   \n"
<<(timelog ? "	timerend  (\"Solving U\",t0)\n" : " " 	        	  	    )
<<"										   \n"
<<"										   \n"
<<"		uold[]=uold[]-u[];						   \n"
<<"		phiold[]=phiold[]-phi[]; 					   \n"
<<"		real err1=sqrt( int2d(Th) ( (uold)^2 )  );			   \n"
<<"		real err2=sqrt( int2d(Th) ( (phiold)^2 )  );			   \n"
<<"		cout.scientific << \" Iter \" << iter<< \"  error in u \"<< err1   \n"
<<"		<<\"  error in phi \"<< err2<<endl;				   \n"
<<"										   \n"
<<"										   \n"
<<"		phiold[]=phi[];							   \n"
<<"		uold[]=u[];							   \n"
<<"										   \n"
<<"		iter++;								   \n"
<<"										   \n"
<<"		if(err1 < 1e-2 && err2 < 1e-2){					   \n"
<<"			cout.scientific << \" Solution converged after \"<<        \n"
<<"			iter <<endl;						   \n"	
<<"			plot(phi,fill=1,value=1);				   \n"
<<"			break;							   \n"
<<"		}								   \n"
<<"	} 									   \n"
<<"	tr+=dtr;								   \n"
<<"}										   \n"
<<"										   \n"	
<<"										   \n"	
<<"										   \n";

if(plotAll){writevarfmatsolve
<<"										   \n"	  
<<"//==============================================================================\n"
<<"// -------Plotting with paraview-------					   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"										   \n"
<<(timelog ? "	timerbegin(\"Post-Processing\",t0)\n" : " "   	        	    )
<<"		load \"../Plugins/iovtk\"				  	   \n" 
<<"		int[int] vtuorder=[1,1,1];		// Solution export order   \n" 
<<"										   \n" 
<<"										   \n"; 
      
if(spc==2)writevarfmatsolve
<<"										   \n"    
<<"savevtk(\"VTUs/Solution-Seq.vtu\",Th,[u,u1,0],phi,				   \n"; 

if(spc==3)writevarfmatsolve
<<"										   \n" 
<<"savevtk(\"VTUs/Solution-Seq.vtu\",Th,[u,u1,u2],phi,			     	   \n"; 
  
writevarfmatsolve       
<<"		order=vtuorder,dataname=\"U phi\");				   \n"
<<(timelog ? "	timerend  (\"Post-Processing\",t0)\n" : " "   	        	    )
<<"										   \n"; 
  
system("mkdir -p VTUs");	  

}  //-- [if loop terminator] plotAll ended --//

}  //-- [if loop terminator] Sequential ended --//

if(!Sequential){writevarfmatsolve
<<"										   \n"
<<"										   \n"	  
<<"//==============================================================================\n"
<<"// -------Sparsity conservation-------					   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"										   \n"
<<"varf DUMMY(uu,vv) =int2d(Th,qforder=1)(uu*vv);				   \n"
<<"										   \n"
<<"matrix<real> MatDUMMY = DUMMY(Vh, Vh);					   \n"
<<"dmatrix A(MatDUMMY, arrayIntersectionP, restrictionIntersectionP, DP);	   \n"
<<"MatDUMMY.resize(0,0);							   \n"
<<"										   \n"
<<"matrix<real> MatDUMMY1 = DUMMY(Vh1, Vh1);					   \n"
<<"dmatrix A1(MatDUMMY1, arrayIntersectionZ, restrictionIntersectionZ, DZ);	   \n"
<<"MatDUMMY1.resize(0,0);							   \n"
<<"										   \n"
<<"matrix<real> ALoc, ALoc1;							   \n"
<<"										   \n"
<<"										   \n"
<<"										   \n"
<<"//==============================================================================\n"
<<"// -------Nonlinear loop-------						   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"										   \n";

if(plotAll)writevarfmatsolve
<<"										   \n"
<<" //------Plotting--------//							   \n"
<<"  exportBegin(\"VTUs/Solution\", mpiCommWorld);				   \n"
<<"  int iterout=0;				      // Loop Counter		   \n"
<<"										   \n";

writevarfmatsolve
<<"										   \n"
<<"while (tr <= maxtr){								   \n"
<<"										   \n"
<<"	if(mpirank==0)cout <<  \"  Applied traction \" << tr <<endl;		   \n"
<<"										   \n"
<<"	if (tr >=5e-3)								   \n"
<<"		dtr = 1e-5;							   \n"
<<"										   \n"
<<"	for(int iter=0; iter<500; iter++){					   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"Matrix Assembly U\",t0)\n" : " "           	    )
<<"		 ALoc = elast(Vh,Vh);			// Assembly bilinear	   \n"
<<(timelog ? "	MPItimerend(\"Matrix Assembly U\",t0)\n" : " "           	    )
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"RHS Assembly U\",t0)\n" : " "           	    )
<<"		 real[int]    b = elast(0,Vh);		// Assembly linear	   \n"
<<(timelog ? "	MPItimerend(\"RHS Assembly U\",t0)\n" : " "           	  	    )
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"PETSc Assembly U\",t0)\n" : " "           	    )
<<"		 changeOperator(A, ALoc);				   	   \n"
<<"		 set(A,sparams =\" \");			// Solver setup		   \n"
<<(timelog ? "	MPItimerend(\"PETSc Assembly U\",t0)\n" : " "          	  	    )
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"Solving U\",t0)\n" : " "         	  	    )
<<"		 u[]=A^-1*b;				// Solve u		   \n"
<<(timelog ? "	MPItimerend(\"Solving U\",t0)\n" : " "           	  	    )
<<"										   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"Matrix Assembly PHI\",t0)\n" : " "           	    )
<<"		 ALoc1 = phase(Vh1,Vh1);		// Assembly bilinear	   \n"
<<(timelog ? "	MPItimerend(\"Matrix Assembly PHI\",t0)\n" : " "       	  	    )
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"RHS Assembly PHI\",t0)\n" : " "           	    )
<<"		 real[int]    b1 = phase(0,Vh1);	// Assembly linear	   \n"
<<(timelog ? "	MPItimerend(\"RHS Assembly PHI\",t0)\n" : " "           	    )
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"PETSc Assembly PHI\",t0)\n" : " "           	    )
<<"		 changeOperator(A1, ALoc1);					   \n"
<<"		 set(A1,sparams =\" \");		// Solver setup		   \n"
<<(timelog ? "	MPItimerend(\"PETSc Assembly PHI\",t0)\n" : " "           	    )
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"Solving PHI\",t0)\n" : " "    		       	    )
<<"		 phi[]=A1^-1*b1;			// Solve phi	  	   \n"
<<(timelog ? "	MPItimerend(\"Solving PHI\",t0)\n" : " "           	  	    )
<<"										   \n"
<<"										   \n"
<<"		uold[]   =uold[]-u[];						   \n"
<<"		phiold[] =phiold[]-phi[]; 					   \n"
<<"										   \n"
<<"		uold[]     .*= DP;						   \n"
<<"		phiold[]   .*= DZ;						   \n"
<<"										   \n"
<<"										   \n"
<<"		real err1Gather,err2Gather;					   \n"
<<"		real err1Loc=sqrt( int2d(Th) ( (uold)^2 )  );			   \n"
<<"		real err2Loc=sqrt( int2d(Th) ( (phiold)^2 )  );			   \n"
<<"										   \n"
<<"		mpiAllReduce(err1Loc,err1Gather,mpiCommWorld,mpiSUM);		   \n"
<<"		mpiAllReduce(err2Loc,err2Gather,mpiCommWorld,mpiSUM);		   \n"
<<"										   \n"
<<"		if(mpirank==0)							   \n"
<<"		cout << \" Iter \" << iter<< \"  error in u \"			   \n"
<<"		     << err1Gather <<\" error in phi \"<< err2Gather<<endl;	   \n"
<<"										   \n"
<<"										   \n"
<<"		phiold[]=phi[];							   \n"
<<"		uold[]=u[];							   \n"
<<"										   \n"
<<"										   \n"
<<"		iter++;								   \n"
<<"										   \n"
<<"		if(err1Gather < 1e-1 && err2Gather < 1e-1){			   \n"
<<"										   \n"
<<"			if(mpirank==0)						   \n"
<<"			cout.scientific << \" Solution converged after \"<<        \n"
<<"			iter <<endl;						   \n"
<<"										   \n";

if(plotAll)writevarfmatsolve
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"Post-Processing\",t0)\n" : " "           	    )
<<"			exportTimeStep2(\"VTUs/Solution\", Th, [u,u1,0],phi, 	   \n"
<<" 					iterout, mpiCommWorld);			   \n"
<<(timelog ? "	MPItimerend  (\"Post-Processing\",t0)\n" : " "       	    	    )
<<"										   \n";

if(debug)writevarfmatsolve
<<"										   \n"				
<<"			plotMPI(Th, phi[], \"Damage\", Zk, def, real, 2, 0)	   \n"
<<"										   \n";

writevarfmatsolve
<<"			break;							   \n"
<<"		}								   \n"
<<"	} 									   \n"
<<"	tr+=dtr;								   \n"
<<"}										   \n"
<<"										   \n"	
<<"										   \n";

if(plotAll)writevarfmatsolve
<<"										   \n"
<<"  exportEnd(\"VTUs/Solution\", mpiCommWorld);				   \n"
<<"										   \n";

}  //-- [if loop terminator] !Sequential ended --//
 
}  //-- [if loop terminator] nonlinear ended --//

if(!nonlinear){

if(!Sequential){writevarfmatsolve      
<<"										   \n"	
<<"//==============================================================================\n"
<<"//  -------Local Au=b assembly and solving-------				   \n"
<<"//==============================================================================\n"	
<<"										   \n"
<<"										   \n"
<<"//-----------------Assembly for A-----------------//				   \n"
<<"										   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"Matrix Assembly\",t0)\n" : " "           	    )
<<"    matrix<real> ALoc = elast(Vh,Vh);		// Assembly bilinear	   \n"
<<(timelog ? "	MPItimerend  (\"Matrix Assembly\",t0)\n" : " "       	    	    )
<<"										   \n"
<<"										   \n"
<<"//-----------------Assembly for b-----------------//				   \n"
<<"										   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"RHS Assembly\",t0)\n" : " "          	 	    )
<<"      real[int]    b = elast(0,Vh);			// Assembly linear	   \n"
<<(timelog ? "	MPItimerend  (\"RHS Assembly\",t0)\n" : " "       	    	    )
<<"										   \n";

if(pointbc)writevarfmatsolve
<<"										   \n"
<<"//---------Additional assembly for A & b----------//				   \n"
<<"										   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"Point Dirichlet Assembly\",t0)\n" : " "  	    )
<<"      Pointbc(Dpointlab,Vh,ALoc,b,PnV);		// Assembly linear	   \n"
<<(timelog ? "	MPItimerend(\"Point Dirichlet Assembly\",t0)\n" : " "        	    )
<<"										   \n";

writevarfmatsolve
<<"										   \n"
<<" //------------Memory optimization-----------------//			   \n"
<<"										   \n";

if(pointbc)writevarfmatsolve
<<"										   \n"
<<"Dpointlab.resize(0); PnV.resize(0);						   \n"
<<"										   \n";

if(dirichletbc)writevarfmatsolve
<<"										   \n"
<<"Dlabel.resize(0); Dvalue.resize(0);						   \n"
<<"										   \n";

if(tractionbc)writevarfmatsolve
<<"										   \n"
<<"Tlabel.resize(0);								   \n"
<<"										   \n"; 
   
writevarfmatsolve
<<"										   \n"
<<"//---------------PETSc Assembly---------------------//			   \n"
<<"										   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"PETSc Assembly\",t0)\n" : " "  	    		   )
<<"      dmatrix A				// Distributed matrix 		   \n"
<<"		  ( ALoc			, 				   \n"
<<"		    arrayIntersectionP		,				   \n"
<<"                 restrictionIntersectionP	,				   \n"
<<" 		    DP				,				   \n"
<<" 		    bs = "+spc+" 						   \n"
<<"		  );								   \n"
<<(timelog ? "	MPItimerend(\"PETSc Assembly\",t0)\n" : " "  	    		   )
<<"										   \n"
<<"										   \n"
<<"//------------PETSc solving------------------//				   \n"
<<"										   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"PETSc Solving\",t0)\n" : " "  	    		   )
<<"      Vh<real> def(u);							   \n"
<<"      set(A,sparams =\" \");            // Solver setup-Petsc		   \n"
<<"      u[]=A^-1*b;                       // Solving				   \n"
<<"										   \n"
<<(timelog ? "	MPItimerend(\"PETSc Solving\",t0)\n" : " "  	    		   )
<<"										   \n"       
<<"										   \n";

if(plotAll){writevarfmatsolve
<<"										   \n"        
<<"										   \n"          
<<"//==============================================================================\n"
<<"// -------Plotting with paraview-------//					   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"Paraview Plotting\",t0)\n" : " "       		    )
<<" 	int[int] vtuorder=[1,1,1];			// Solution export order   \n" 
<<"	string   namevtu=\"VTUs/Solution\";		// Name of PV files	   \n"
<<"	string   namedata=\"U\";			// Name of export data	   \n"
<<"	bool     withsur=true;				// Export surface mesh	   \n";
  
if(spc==2)writevarfmatsolve
<<"										   \n"
<<"     exportpvd(namevtu, Th,[u,u1,0], vtuorder, withsur, namedata, mpiCommWorld);\n"; 

if(spc==3)writevarfmatsolve
<<"										   \n"
<<"     exportpvd(namevtu, Th,[u,u1,u2], vtuorder, withsur,namedata, mpiCommWorld);\n";    
  
writevarfmatsolve       
<<"										   \n"        
<<(timelog ? "	MPItimerend(\"Paraview Plotting\",t0)\n" : " "       		    )
<<"										   \n";
  
  system("mkdir -p VTUs");

}  //-- [if loop terminator] plotAll ended --//

}  //-- [if loop terminator] !Sequential ended --//

if(Sequential){writevarfmatsolve    
<<"										   \n"	
<<"//==============================================================================\n"
<<"//  -------Local Au=b assembly and solving-------				   \n"
<<"//==============================================================================\n"	
<<"										   \n"
<<(timelog ? "	timerbegin(\"Matrix Assembly\",t0)\n" : " "  	    		   )
<<"		matrix<real> A = elast(Vh,Vh);		// Assembly for A	   \n"
<<(timelog ? "	timerend  (\"Matrix Assembly\",t0)\n" : " "  	    		   )
<<(timelog ? "	timerbegin(\"RHS Assembly\",t0)\n" : " "  	    		   )
<<"		real[int]    b = elast(0,Vh);		// Assembly for b	   \n"
<<(timelog ? "	timerend  (\"RHS Assembly\",t0)\n" : " "  	    		   )
<<(timelog ? "	timerbegin(\"Solving U\",t0)\n" : " "  	    		   	   )
<<"		set(A,solver=CG);			// Solver setup		   \n"
<<"		u[]=A^-1*b;				// Solving		   \n"
<<(timelog ? "	timerend  (\"Solving U\",t0)\n" : " "  	   	 		   )
<<"										   \n"
<<"										   \n";

if(plotAll){writevarfmatsolve
<<"										   \n"	
<<"//==============================================================================\n"
<<"// -------Plotting with paraview-------					   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<(timelog ? "	timerbegin(\"Post-Processing\",t0)\n" : " "  	    		   )
<<"		load \"../Plugins/iovtk\"				  	   \n" 	
<<"		int[int] vtuorder=[1,1,1];		// Solution export order   \n"; 
  
if(spc==2)writevarfmatsolve
<<"		savevtk( \"VTUs/Solution-Seq.vtu\"	,			   \n"
<<"			  Th				,			   \n"
<<"			  [u,u1,0]			,			   \n";
 
if(spc==3)writevarfmatsolve     
<<"		savevtk(\"VTUs/Solution-Seq.vtu\"	,			   \n"
<<"			  Th				,			   \n"
<<"			  [u,u1,u2]			,			   \n"; 
  
writevarfmatsolve       
<<"			  order=vtuorder		,			   \n"
<<"			  dataname=\"U\"					   \n"
<<"		       );				   			   \n"
<<(timelog ? "	timerend  (\"Post-Processing\",t0)\n" : " "  	    		   )	
<<"										   \n";
  
system("mkdir -p VTUs");
	  
}  //-- [if loop terminator] plotAll ended --//

}  //-- [if loop terminator] Sequential ended --//

}  //-- [if loop terminator] !nonlinear ended --//



} //-- [ostream terminator]  varfmatsolve.edp closed --//
