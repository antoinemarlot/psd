/*******************************************************************************
*									       *
* Date:	   04/03/2019							       *
* Type:    Execution file						       *
* Comment: This main file generates three files: macro.edp, varfmatsolve.edp,  *
*          and   meshPartitioning.edp.  Commandline  arguments  controls  the  *
*          generated file nature.	 		       		       *
* To run : ff-mpirun -np 1 main.edp -v 0 -ns -nw			       *
*									       *
*******************************************************************************/

//==============================================================================
// All command line argument descriptions
//==============================================================================
/*
  -dimension   [int]	  Accepts values 2 or 3. Default 2. 2 for 2D 3 for 3D.
  
  -lagrange    [int]      Lagrange order used for building FE space. Options are 
  			  1 for P1 or 2 for P2. Defaut is P1.  
  
  -partitioner [sting]    Mesh partitioner to be used. Options are "metis"
  			  "parmetis" "scotch" or "ptstoch".
  			
  -partitioner parmetis   Mesh partitioner is parmetis. Additional option is 
  			  active '-parmetis_worker [int]'.			
  			  
  -help        [bool]     To activate helping message on the terminal.  			  
  			  
  -plot        [bool]     To activate plotting routine. Default is false.
  
  -pointbc     [bool]     To activate Dirichlet boundary condition on point.
  
  -bodyforce   [bool]     To activate volumetric source term (body force).
  
  -dirichletbc [bool]     To activate Dirichlet boundary condition.
  
  -tractionbc  [bool]     To activate traction boundary condition (Neumann).  

  -sequential  [bool]	  To generate a sequential ff++ solver. Default OFF.

*/

//==============================================================================
// All files to be included
//==============================================================================

  include "getARGV.idp"    	// Enables importing commandline arguments
  //include "parameters.edp"  	//Control parameters, propeties, etc..

//==============================================================================
// All variables
//==============================================================================
  int spc = getARGV("-dimension", 2);
  int lag = getARGV("-lagrange" , 1); 
  
  string Partitioner=getARGV("-partitioner", "parmetis");

  bool help        =  usedARGV("-help")        != -1;
  bool plotAll     =  usedARGV("-plot")        != -1;
  bool pointbc     =  usedARGV("-pointbc")     != -1;
  bool bodyforce   =  usedARGV("-bodyforce")   != -1;
  bool nonlinear   =  usedARGV("-nonlinear")   != -1;   
  bool tractionbc  =  usedARGV("-tractionbc")  != -1; 
  bool Sequential  =  usedARGV("-sequential")  != -1;      
  bool dirichletbc =  usedARGV("-dirichletbc") !=  1;


  
//==============================================================================   
// Help message on the screen
//==============================================================================

if(help){

cout 
<<"\n"
<<"================================================================================\n"
<<"                       ----YOU ACTIVATED THE HELP OPTION----\n"
<<"                      Please read the messages below carefully\n"
<<"================================================================================\n"
<<"\n";

 
cout 
<<" According to the flags provided You are solving A "+spc+"D problem.\n\n"
<<"   # With"<<(bodyforce ? "" : "out")<<" bodyforce acting on the volume.\n"
<<"   # With"<<(tractionbc ? "" : "out")<<" traction boundary condition.\n"
<<"   # With"<<(dirichletbc ? "" : "out")<<" Dirichlet boundary condition on surface.\n"
<<"   # With"<<(pointbc ? "" : "out")<<" Dirichlet boundary condition on a point.\n"
<<"   # Paraview plotting is "<<(plotAll ? "en" : "dis")<<"abled.\n"
<<"\n";


cout
<<" WARNING If something doesn't look right consider rerunning with correct flags.\n"
<<"\n"; 

cout 
<<"\n"
<<"/***********************************IMPORTANT***********************************\n"
<<"*                                                                              *\n"
<<"* To change the mesh and the material parameters edit 'parameters.edp'         *\n"
<<"*                                                                              *\n"
<<"* 1. Edit  <<ThName>> the [string] name of your mesh  file  with  location. By *\n"
<<"*    default it is ThName= <<../Meshes/2D/Meshes/bar2D>> .			  *\n"
<<"*                                                                              *\n"
<<"* 2. Edit <<E,nu,f1,f2,f3>>  of [real] type representing the materials modulus *\n"
<<"*    of elasticity, poissions ratio, body forces f1,f2,f3 in x,y,z directions. *\n"
<<"*                                                                              *\n"
<<"*******************************************************************************/\n"
<<"\n";

if(dirichletbc)
cout 
<<"\n"
<<"/***********************************IMPORTANT***********************************\n"
<<"*                                                                              *\n"
<<"* Using Dirichlet BC  please edit the file 'varfmatsolve.edp'                  *\n"
<<"*                                                                              *\n"
<<"* 1. Edit  <<Dlabel>> i.e. the  [int]   vector   of  labels  that contain your *\n"
<<"*    Dirichlet border. So  if your border is labeled 1 Dlabel=[1], if you have *\n"
<<"*    two Dirichlet borders 4 & 5 then  Dlabel = [4,5].                         *\n"
<<"*                                                                              *\n"
<<"* 2. Edit <<Dvalue>> i.e the [real] vector defined by Dirichlet  values.  Each *\n"
<<"*    Dirichlet borders  will need  Dirichlet field values. So e.g.  Dlabel=[1] *\n"
<<"*    you can use Dvalue=[1.,0.], meaning u1=1, and u2=0                        *\n"
<<"*                                                                              *\n"
<<"*******************************************************************************/\n"
<<"\n"; 

 

if(bodyforce)
cout 
<<"\n"
<<"/***********************************IMPORTANT***********************************\n"
<<"*                                                                              *\n"
<<"* Using bodyforce within the problem please edit the file 'varfmatsolve.edp'   *\n"
<<"*                                                                              *\n"
<<"* 1. Edit macro <<BF>> and  provide three components of  bodyforce. Note  that *\n"
<<"*    the macro accepts real or functional values.                              *\n" 
<<"*                                                                              *\n"
<<"*******************************************************************************/\n"
<<"\n"; 




if(pointbc)
cout 
<<"\n"
<<"/***********************************IMPORTANT***********************************\n"
<<"*                                                                              *\n"
<<"* Using Dirichlet BC on  point please edit the file 'varfmatsolve.edp'         *\n"
<<"*                                                                              *\n"
<<"* 1. Edit <<Dpointlab>> i.e. the  [int]   vector of  labels  that contain your *\n"
<<"*    Dirichlet Point. So if your point is on line 4 Dpointlab = [4].           *\n"
<<"*                                                                              *\n"
<<"* 2. Edit <<PnV>> i.e  the [real] vector defined by  [x,y,u1,u2]. Here (x,y) & *\n"
<<"*    (u1,u2) are coordinates and deformation values of the Dirichlet point.    *\n"
<<"*                                                                              *\n"
<<"*******************************************************************************/\n"
<<"\n"; 



if(tractionbc)
cout 
<<"\n"
<<"/***********************************IMPORTANT***********************************\n"
<<"*                                                                              *\n"
<<"* Using Neumann BC  please edit the file 'varfmatsolve.edp'                    *\n"
<<"*                                                                              *\n"
<<"* 1. Edit <<Tlabel>>  i.e. the  [int]   vector   of  labels  that contain your *\n"
<<"*    traction border. So  if your borders is labeled 1 Tlabel=[1], if you have *\n"
<<"*    two traction borders 4 & 5 then  Tlabel = [4,5].                          *\n"
<<"*                                                                              *\n"
<<"* 1. Edit macro <<T>> & provide three components of  traction on the boundary. *\n"
<<"*                                                                              *\n"
<<"*******************************************************************************/\n"
<<"\n";  


}


//==============================================================================
// Building the macros.edp file
//==============================================================================
   
{ofstream  writemacros("macros.edp");

writemacros
<<"\n"
<<"/******************************Userdefined macros*******************************\n"
<<"*                                                                              *\n"
<<"* Note!!! This file is  generated  by running scriptGenerator.edp. Do not edit *\n"
<<"*         in order to  control this  file please change flag arguments of  the *\n"
<<"*         scriptGenerator, details of which are present in scriptGenerator.edp *\n"
<<"*         or in the README.MD file.                                            *\n"
<<"*                                                                              *\n"
<<"*******************************************************************************/\n"
<<"\n";
  

if(spc==2){
writemacros
<<"  func Pk = [P"+lag+",P"+lag+"];\t			// Finite element space\n"
<<"  macro  partitioner()"+Partitioner+"\t		// Mesh partitioner used\n"
<<"  macro dimension() 2				// Two-dimensional problem\n"
<<"  macro init(i)[i, i]				// Vector field initialization\n"
<<"  macro def(i)[i, i#1]				// Vector field definition\n"
<<"  macro divergence(i)(dx(i) + dy(i#1))		// Divergence function\n"
<<"  macro epsilon(i) [dx(i), dy(i#1),\n" 
<<"                   (dy(i)+dx(i#1))/sqrt(2.0)]	// Strain definition\n";

if(nonlinear)
writemacros
<<"  macro grad(i)[dx(i), dy(i)]			// Two-dimensional gradient\n"
<<"  macro sxx(i)(lambda*divergence(i)+2*mu*dx(i))	// Sigma_xx\n"
<<"  macro syy(i)(lambda*divergence(i)+2*mu*dy(i#1))	// Sigma_yy\n"
<<"  macro sxy(i)(mu*((dy(i)+dx(i#1))))			// Sigma_yx=Sigma_xy\n"
<<"  macro sig(i) [sxx(i),syy(i),2*sqrt(2.0)*sxy(i)] 	// Sigma\n"
<<"  macro Hplus(i)(0.5*(sig(i)'*epsilon(i)))		// Hplus (elastic energy)\n";
   
  
if(Sequential)
writemacros
<<"  macro meshN()mesh				// Two-dimensional problem\n"
<<"  macro intN()int2d				// Two-dimensional integral\n"
<<"  macro intN1()int1d				// One-dimensional integral\n"
<<"  macro readmeshN()readmesh			// Two-dimensional 'mesh' reader\n"
<<"  macro gmshloadN()gmshload			// Two-dimensional 'msh' reader\n";
}



if(spc==3){
writemacros
<<"  func Pk = [P"+lag+",P"+lag+",P"+lag+"];\t\t\t	// Finite element space\n"
<<"  macro  partitioner()"+Partitioner+"\t		// Mesh partitioner used\n"
<<"  macro init(i) [i,   i,   i]			// Vector field initialization\n"
<<"  macro dimension() 3				// Three-dimensional problem\n"
<<"  macro def(i)  [i, i#1, i#2]			// Vector field definition\n"
<<"  macro divergence(i) (dx(i)+dy(i#1)+dz(i#2))	// Divergence function\n"
<<"  macro epsilon(i) [dx(i), dy(i#1), dz(i#2),\n"
<<"                   (dz(i#1)+dy(i#2))/sqrt(2.0),\n"
<<"                   (dz(i) + dx(i#2))/sqrt(2.0),\n"
<<"                   (dy(i) + dx(i#1))/sqrt(2.0)]	// Strain definition\n";

if(nonlinear)
writemacros
<<"  macro grad(i)[dx(i), dy(i), dz(i)]			// Three-dimensional gradient\n"
<<"  macro sxx(i)(lambda*divergence(i)+2*mu*dx(i))	// Sigma_xx\n"
<<"  macro syy(i)(lambda*divergence(i)+2*mu*dy(i#1))	// Sigma_yy\n"
<<"  macro szz(i)(lambda*divergence(i)+2*mu*dz(i#2))	// Sigma_zz\n";

if(Sequential)
writemacros
<<"  load \"msh3\"				// Loading 3D mesh\n"
<<"  macro meshN()mesh3				// Three-dimensional problem\n"
<<"  macro intN()int3d				// Three-dimensional integral\n"
<<"  macro intN1()int2d				// Two-dimensional integral\n"
<<"  macro readmeshN()readmesh3			// Three-dimensional problem\n"
<<"  macro gmshloadN()gmshload3			// Three-dimensional 'msh' reader\n";
}





if(pointbc){

writemacros
<<"\n"
<<"  //------------Point BC macro------------------//\n"
<<"  macro Pointbc(Dpointlab,Wh,A,b,PnV){\n"
<<"    int count=0;\n"
<<"    meshN Th=Wh.Th;\n"
<<"\n";

 
if(spc==2)
writemacros 
<<"    varf vlabs(def(u),def(v)) = on( Dpointlab, u=-1*(x==PnV[0] && y==PnV[1]),\n"
<<"                                  u1 = -1*(x==PnV[0] && y==PnV[1]) );\n"
<<"\n";

if(spc==3)
writemacros
<<"    varf vlabs(def(u),def(v)) = on( Dpointlab, u=-1*(x==PnV[0] && y==PnV[1] && z==PnV[2]),\n"
<<"                                  u1 = -1*(x==PnV[0] && y==PnV[1] && z==PnV[2] ),\n"
<<"                                  u2 = -1*(x==PnV[0] && y==PnV[1] && z==PnV[2] )  );\n"
<<"\n";


writemacros  
<<"    real[int] absc=vlabs(0,Wh);\n"
<<"    for (int i=0; i<Wh.ndof; i++){\n"
<<"      if(abs(-1e+30-absc(i))==0 ){\n"
<<"        A(i,i)=tgv;\n"
<<"        b[i]=PnV["+spc+"+count]*tgv;\n"
<<"        count++;\n"
<<"         if(count=="+spc+") break;\n"
<<"      }\n"
<<"    }\n"
<<"  }\n"
<<"  //--------------------------------------------//\n"
<<"\n"; 

}

if(!Sequential)
writemacros
<<"  load    \"PETSc\"				// PETSc plugin activated\n"
<<"  include \"../Plugins/DDmacro.edp\"		// All domain decomposition macros\n";

}  


//==============================================================================
// Building the parameters.edp file
//==============================================================================

{ofstream  writemeshParameters("parameters.edp");

writemeshParameters
<<"										   \n"
<<"/***********************************Parameters**********************************\n"
<<"*                                                                              *\n"
<<"* Note!!! This file is  generated  by running scriptGenerator.edp. Do not edit *\n"
<<"*         in order to  control this  file please change flag arguments of  the *\n"
<<"*         scriptGenerator, details of which are present in scriptGenerator.edp *\n"
<<"*         or in the README.MD file.                                            *\n"
<<"*                                                                              *\n"
<<"*******************************************************************************/\n"
<<"										   \n"
<<"										   \n"
<<"										   \n"
<<"//==============================================================================\n"
<<"// -------FEM mesh to be loaded (Un-partitioned)------- 			   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"										   \n"
<<"string ThName = \"../Meshes/"+spc+"D/Meshes/bar2D\";  	// Mesh file name  \n"
<<"										   \n"
<<"										   \n"
<<"//==============================================================================\n"
<<"// -------Material properties------- 		 			   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"										   \n"
<<"										   \n"
<<"real mu,lambda,t0 "<<(bodyforce ? ",f2" : "")<<";				   \n"
<<"{										   \n"
<<"real E=200.e9,				//Modulus of Elasticity - [Pa]	   \n"
<<"	nu=0.3;					// Poisson ratio - [-]		   \n"
<<"	 									   \n"
<<"mu= E/(2.*(1.+nu));								   \n"
<<"lambda = E*nu/((1.+nu)*(1.-2.*nu));						   \n"
<<"	 									   \n"
<<"	 									   \n"
<<(bodyforce ? "f2=8.e3*(-9.81);				// Rho*g" : "")<<" \n"
<<"	 									   \n"
<<"}	 									   \n"
<<"	 									   \n"
<<"	 									   \n";

if(nonlinear)
writemeshParameters
<<"//==============================================================================\n"
<<"// -------Nonlinear parameters------- 		 			   \n"
<<"//==============================================================================\n"
<<"	 									   \n"
<<"real Gc =2.7,								   \n"
<<"	lo,									   \n"
<<"	lfac=2,									   \n"
<<"	maxtr = 0.03,								   \n"
<<"	tr = 1e-5,								   \n"
<<"	dtr = 1e-5;								   \n"
<<"	 									   \n";

}


//==============================================================================
// Building the meshPartitioning.edp file
//==============================================================================
  
{ofstream  writemeshPartitioning("meshPartitioning.edp");

writemeshPartitioning
<<"										   \n"
<<"/*****************************Mesh And Partitioning*****************************\n"
<<"*                                                                              *\n"
<<"* Note!!! This file is  generated  by running scriptGenerator.edp. Do not edit *\n"
<<"*         in order to  control this  file please change flag arguments of  the *\n"
<<"*         scriptGenerator, details of which are present in scriptGenerator.edp *\n"
<<"*         or in the README.MD file.                                            *\n"
<<"*                                                                              *\n"
<<"*******************************************************************************/\n"
<<"										   \n";

if(spc==2)
writemeshPartitioning 
<<"meshN Th = square(1, 1);		// This is a dummy mesh for now\n";

if(spc==3)
writemeshPartitioning 
<<"meshN Th = cube(1, 1, 1);		// This is a dummy mesh for now\n";

writemeshPartitioning 
<<"fespace Vh(Th, Pk);			// Local mixed FE space\n";

if(Sequential)
writemeshPartitioning
<<"load \"gmsh\"				// Load meshes from gmsh\n"
<<"Th = gmshloadN(\"\"+ThName+\".msh\");	// Global mesh loaded\n\n";

if(!Sequential)
writemeshPartitioning
<<"int[int] arrayIntersection;                // Ranks of neighboring subdomains\n"
<<"int[int][int] restrictionIntersection(0);  // Local-to-neighbors renumbering\n"
<<"real[int] D;                               // Partition of unity\n"
<<"\n"

<<"//==============================================================================\n"
<<"// -------Function building the restriction matrix and partion of unity-------//\n"
<<"//==============================================================================\n\n"
<<"func int PartThAndBuildCommunication(){\n"
<<"  int s = getARGV(\"-split\", 1);                    // refinement factor\n\n"

<<"  load \"gmsh\"                                      // Load meshes from gmsh\n"
<<"  meshN ThGlobal = gmshloadN(\"\"+ThName+\".msh\");    // Global mesh loaded\n\n"

<<"  PETScMPIBuild(Th, ThGlobal, s, D, arrayIntersection,\n" 
<<"      restrictionIntersection, Vh, Pk, mpiCommWorld)\n\n"

<<"  return 0;\n"
<<"}\n\n"

<<"mpiBarrier(mpiCommWorld);\n"
<<"t0 = mpiWtime(); \n"
<<"if(mpirank==0)"
<<"cout << \"Mesh partitioning with \"<< Stringification(partitioner)<<\"\\n\";\n\n"
      
<<"    PartThAndBuildCommunication();\n\n"

<<"mpiBarrier(mpiCommWorld);\n"
<<"if(mpirank==0)"
<<"cout << \"Mesh partitioning  ended in :----------------->\"<< mpiWtime()-t0 <<\"\\n*\\n\";\n\n";

}


//==============================================================================
// Building the varfmatsolve.edp file
//==============================================================================

{ofstream  writevarfmatsolve("varfmatsolve.edp");

writevarfmatsolve
<<"										   \n"
<<"/**************Variational formulation, solving, & post-proc *******************\n"
<<"*                                                                              *\n"
<<"* Note!!! This file is  generated  by running scriptGenerator.edp. Do not edit *\n"
<<"*         in order to  control this  file please change flag arguments of  the *\n"
<<"*         scriptGenerator, details of which are present in scriptGenerator.edp *\n"
<<"*         or in the README.MD file.                                            *\n"
<<"*                                                                              *\n"
<<"*******************************************************************************/\n"
<<"										   \n"
<<"										   \n"
<<"//==============================================================================\n"
<<"// -------Dirichlet and Neumann conditions-------				   \n"
<<"//==============================================================================\n"
<<"										   \n";


if(dirichletbc){

writevarfmatsolve
<<"//---Surface---//\n"
<<"int [int]   Dlabel=[2];			// Vector containing Dirichlet labels \n";

if(spc==2)
writevarfmatsolve
<<"real[int]   Dvalue=[0.,0.];		// Vector containing Dirichlet values \n\n";

if(spc==3) 
writevarfmatsolve
<<"real[int]   Dvalue=[0.,0.,0.];		// Vector containing Dirichlet values \n\n"; 

}


if(pointbc){

writevarfmatsolve
<<"//---Point---//\n"
<<"int [int]   Dpointlab=[2];		// Vector containing Dirichlet labels\n"
<<"real[int]   PnV=[0., 0., 0., 0.];	// [x, y, u1, u2]\n\n";

}

if(bodyforce){

writevarfmatsolve
<<"//---Body force---//\n";

if(spc==2)
writevarfmatsolve
<<"macro BF [0,f2]				//EOM\n\n"; 

if(spc==3)
writevarfmatsolve
<<"macro BF [0,f2,0]				//EOM\n\n"; 
      
}

if(tractionbc){

writevarfmatsolve
<<"//---Neumann---//\n"
<<"int [int]   Tlabel=[2];			// Vector containing Neumann labels \n";

if(spc==2)
writevarfmatsolve
<<"macro T [0,1]				//EOM\n"; 

if(spc==3)
writevarfmatsolve
<<"macro T [0,1,0]			//EOM\n"; 

}


if(!nonlinear){

writevarfmatsolve
<<"										   \n"
<<"//==============================================================================\n"
<<"// -------Variation formulation linear-------				   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"										   \n";

writevarfmatsolve
<<"varf elast(def(u),def(v))\n"
<<"	= intN(Th,qforder=3)(\n"
<<"			lambda*divergence(u)*divergence(v)\n"
<<"			+2.*mu*( epsilon(u)'*epsilon(v) )\n"
<<"		  )\n";

if(bodyforce)
writevarfmatsolve
<<"	+ intN(Th,qforder=2)(BF'*def(v))		// Body force   (volumetric)\n";


if(tractionbc)
writevarfmatsolve
<<"	+ intN1(Th,Tlabel,qforder=2)(T'*def(v))		// Traction force (Neumann BC)\n";

if(dirichletbc){

if(spc==2)
writevarfmatsolve
<<"	+ on(Dlabel,u=Dvalue[0],u1=Dvalue[1]);	// Displacement (Dirichlet)\n\n";

if(spc==3)
writevarfmatsolve
<<"	+ on(Dlabel,u=Dvalue[0],u1=Dvalue[1],u2=Dvalue[2]);	// Displacement (Dirichlet)\n\n";

}
}

if(nonlinear){

writevarfmatsolve
<<"										   \n"
<<"//==============================================================================\n"
<<"// -------Variation formulation nonlinear-------				   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"										   \n"
<<"Vh<real> def(u), def(uold);		// Defining displacement variables	   \n"
<<"										   \n"
<<"fespace Vh1(Th,P1);			// FEspace for damage field		   \n"
<<"	Vh1 phi,phiold;			// Damage field				   \n"
<<"										   \n"
<<"										   \n"
<<"										   \n"
<<"varf elast(def(u),def(v))							   \n"
<<"	= intN(Th,qforder=3)(							   \n"
<<"			((1 - phiold)*(1 - phiold) + 1e-6)*			   \n"
<<"			(lambda*divergence(u)*divergence(v)			   \n"
<<"			+2.*mu*( epsilon(u)'*epsilon(v) ))			   \n"
<<"			    )							   \n";

if(bodyforce)
writevarfmatsolve
<<"	+ intN(Th,qforder=2)(BF'*def(v))	// Body force   (volumetric)	   \n";

if(tractionbc)
writevarfmatsolve
<<"	+ intN1(Th,Tlabel,qforder=2)(T'*def(v))	// Traction force (Neumann BC)	   \n";

if(dirichletbc){

if(spc==2)
writevarfmatsolve
<<"	+ on(Dlabel,u=Dvalue[0],u1=Dvalue[1]);	// Displacement (Dirichlet)\n\n";

if(spc==3)
writevarfmatsolve
<<"	+ on(Dlabel,u=Dvalue[0],u1=Dvalue[1],u2=Dvalue[2]);	// Displacement (Dirichlet)\n\n";

}


writevarfmatsolve
<<"varf phase(phi,q)								\n"
<<"	= intN(Th,qforder=3)(							\n"
<<"			(Gc*lo*(grad(phi)'*grad(q))) +				\n"
<<"			( ((Gc/lo)  + 2.*Hplus(u))*phi*q )			\n"
<<"			    )							\n"
<<"	+ intN(Th,qforder=2)(  2.*Hplus(u)*q  )					\n"
<<"	+ on(4,phi=1);				// Already Cracked (Dirichlet)  \n";

}


if(nonlinear){

writevarfmatsolve
<<"										   \n"
<<"//==============================================================================\n"
<<"// -------Nonlinear parameter calulations-------				   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"										   \n"
<<"{										   \n"
<<" fespace Vh0(Th,P0);								   \n"
<<" Vh0 size1=hTriangle;							   \n"
<<" lo=size1[].min;								   \n"
<<" lo=lo*lfac;									   \n"
<<"}										   \n"


<<"//==============================================================================\n"
<<"// -------Nonlinear loop-------						   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"										   \n"
<<"										   \n"
<<"while (tr <= maxtr){								   \n"
<<"										   \n"
<<"	if (tr >=5e-3)								   \n"
<<"		dtr = 1e-5;							   \n"
<<"										   \n"
<<"	int  iter  = 1;								   \n"
<<"	real toll  = 1e-3,							   \n"
<<"	     err1  = 1,								   \n"
<<"	     err2  = 1;								   \n"
<<"										   \n"
<<"	cout <<  \"  Applied traction \" << tr <<endl;				   \n"
<<"										   \n"
<<"										   \n"
<<"	while (err1 > toll && err1 > toll){					   \n"
<<"		matrix<real> A = elast(Vh,Vh);		// Assembly for A	   \n"
<<"		real[int]    b = elast(0,Vh);		// Assembly for b	   \n"
<<"		set(A,solver=CG);			// Solver setup		   \n"
<<"		u[]=A^-1*b;				// Solve		   \n"
<<"										   \n"
<<"										   \n"
<<"		matrix<real> A1 = phase(Vh1,Vh1);	// Assembly for A	   \n"
<<"		real[int]    b1 = phase(0,Vh1);		// Assembly for b	   \n"
<<"		set(A1,solver=CG);			// Solver setup		   \n"
<<"		phi[]=A1^-1*b1;				// Solve		   \n"
<<"										   \n"
<<"										   \n"
<<"		uold[]=uold[]-u[];						   \n"
<<"		phiold[]=phiold[]-phi[]; 					   \n"
<<"		err1=sqrt( int2d(Th) ( (uold)^2 )  );				   \n"
<<"		err2=sqrt( int2d(Th) ( (phiold)^2 )  );				   \n"
<<"		cout.scientific << \" Iter \" << iter<< \"  error in u \"<< err1   \n"
<<"		<<\"  error in phi \"<< err2<<endl;				   \n"
<<"										   \n"
<<"										   \n"
<<"		phiold[]=phi[];							   \n"
<<"		uold[]=u[];							   \n"
<<"										   \n"
<<"		iter++;								   \n"
<<"										   \n"
<<"		if(err1 < toll && err1 < toll){					   \n"
<<"			cout.scientific << \" Solution converged after \"<<        \n"
<<"			iter <<endl;						   \n"	
<<"			plot(phi,fill=1,value=1);				   \n"
<<"		}								   \n"
<<"	} 									   \n"
<<"	tr+=dtr;								   \n"
<<"}										   \n"
<<"										   \n"	
<<"										   \n"	
<<"										   \n";

if(plotAll){
  system("mkdir -p VTUs");
   
  writevarfmatsolve
  <<"//==============================================================================\n"
  <<"// -------Plotting with paraview-------					     \n"
  <<"//==============================================================================\n"
  <<"										     \n"
  <<"										     \n"
  <<"load  \"../Plugins/iovtk\"			// Loading the vtk viz module	     \n"
  <<"int[int] vtuorder=[1,1,1];			// Solution export order	     \n" 
  <<"										     \n" 
  <<"										     \n"; 
      
  if(spc==2)
     writevarfmatsolve
     <<"savevtk(\"VTUs/Displacements-Seq.vtu\",Th,[u,u1,0],phi,			     \n"; 
  if(spc==3)
     writevarfmatsolve
     <<"savevtk(\"VTUs/Displacements-Seq.vtu\",Th,[u,u1,u2],phi,		     \n"; 
  
  writevarfmatsolve       
  <<"		order=vtuorder,dataname=\"Displacement\");			     \n"
  <<"										     \n"; 	  
}
 
}

if(!nonlinear){

if(!Sequential){
writevarfmatsolve       
<<"										   \n"	
<<"//==============================================================================\n"
<<"//  -------Local Au=b assembly and solving-------				   \n"
<<"//==============================================================================\n"	
<<"										   \n"
<<"										   \n"
<<"//------------Assembly for A------------------//\n"
<<" mpiBarrier(mpiCommWorld);\n"
<<" t0 = mpiWtime(); \n"
<<" if(mpirank==0)cout << \"Matrix assembly began\\n\";\n"
<<"      matrix<real> ALoc = elast(Vh,Vh);\n"
<<" mpiBarrier(mpiCommWorld);\n"
<<" if(mpirank==0)cout << \"Matrix assembly ended in :-------------------->\"<< mpiWtime()-t0 <<\"\\n*\\n\";\n\n\n\n"


<<"//------------Assembly for b------------------//\n"
<<" mpiBarrier(mpiCommWorld);\n"
<<" t0 = mpiWtime(); \n"
<<" if(mpirank==0)cout << \"RHS assembly began\\n\";\n"
<<"      real[int]    b = elast(0,Vh);\n"
<<" mpiBarrier(mpiCommWorld);\n"
<<" if(mpirank==0)cout << \"RHS assembly ended in :----------------------->\"<< mpiWtime()-t0 <<\"\\n*\\n\";\n\n\n\n";


if(pointbc){

writevarfmatsolve
<<"//-----Additional assembly for A & b--------//\n"
<<" mpiBarrier(mpiCommWorld);\n"
<<" t0 = mpiWtime(); \n"
<<" if(mpirank==0)cout << \"Point Dirichlet assembly began\\n\";\n"
<<"      Pointbc(Dpointlab,Vh,ALoc,b,PnV);\n"
<<" mpiBarrier(mpiCommWorld);\n"
<<" if(mpirank==0)cout << \"Point Dirichlet assembly ended in :----------->\"<< mpiWtime()-t0 <<\"\\n*\\n\";\n\n\n\n";

}


writevarfmatsolve
<<" //------------Memory optimization-----------------//\n";
if(pointbc)
writevarfmatsolve
<<"Dpointlab.resize(0); PnV.resize(0);\n";
if(dirichletbc)
writevarfmatsolve
<<"Dlabel.resize(0); Dvalue.resize(0);\n";
if(tractionbc)
writevarfmatsolve
<<"Tlabel.resize(0);\n"; 
   
writevarfmatsolve 
<<"\n\n"		    
<<"//------------Sharing with PETSc------------------//\n"
<<" mpiBarrier(mpiCommWorld);\n"
<<" t0 = mpiWtime(); \n"
<<" if(mpirank==0)cout << \"Sharing with PETSc began\\n\";\n"
<<"      dmatrix A(ALoc, arrayIntersection,\n"
<<"                restrictionIntersection, D, bs = "+spc+");// Distributed matrix\n"
<<" mpiBarrier(mpiCommWorld);\n"
<<" if(mpirank==0)cout << \"Sharing with PETSc ended in :----------------->\"<< mpiWtime()-t0 <<\"\\n*\\n\";\n\n\n\n"


<<"//------------PETSc solving------------------//\n"
<<" mpiBarrier(mpiCommWorld);\n"
<<" t0 = mpiWtime(); \n"
<<" if(mpirank==0)cout << \"Solving with PETSc began\\n\";\n"
<<"      Vh<real> def(u);\n"
<<"      set(A,sparams =\" \");            // Solver setup-Petsc\n"
<<"      u[]=A^-1*b;                     // Solving\n"
<<" mpiBarrier(mpiCommWorld);\n"
<<" if(mpirank==0)cout << \"Solving with PETSc ended in :----------------->\"<< mpiWtime()-t0 <<\"\\n*\\n\";\n\n";


if(plotAll){
  system("mkdir -p VTUs");
   
  writevarfmatsolve
  <<"//==============================================================================\n"
  <<"// -------Plotting with paraview-------//\n"
  <<"//==============================================================================\n\n"

  <<"load  \"../Plugins/iovtk\"                       // Loading the vtk viz module\n"

  <<"//------------Paraview plotting------------------//\n"
  <<" mpiBarrier(mpiCommWorld);\n"
  <<" t0 = mpiWtime(); \n"
  <<" if(mpirank==0)cout << \"Post-processing began\\n\";\n"

  <<" 	int[int] vtuorder=[1,1,1];			// Solution export order\n" 
  <<"	string   namevtu=\"VTUs/Displacements\";	// Name of PV files\n"
  <<"	string   namedata=\"Displacements\";		// Name of export data\n"
  <<"	bool     withsur=true;				// Export surface mesh\n";
  
  if(spc==2)
     writevarfmatsolve
     <<"      exportpvd(namevtu, Th, [u,u1,0], vtuorder, withsur, namedata, mpiCommWorld);\n"; 
  if(spc==3)
     writevarfmatsolve
     <<"      exportpvd(namevtu, Th, [u,u1,u2], vtuorder, withsur, namedata, mpiCommWorld);\n";    
  
  writevarfmatsolve       
  <<" mpiBarrier(mpiCommWorld);\n"
  <<" if(mpirank==0)cout << \"Post-processing ended in :--------------------->\"<< mpiWtime()-t0 <<\"\\n*\\n\";\n\n"; 
  

}

writevarfmatsolve
<<"if(mpirank==0)cout << \"--------------------------------------------------------------------------\\n\\n\";\n\n";

}

if(Sequential){
writevarfmatsolve       
<<"										   \n"	
<<"//==============================================================================\n"
<<"//  -------Local Au=b assembly and solving-------				   \n"
<<"//==============================================================================\n"	
<<"										   \n"
<<"										   \n"
<<"Vh<real> def(u);				// Defining LHS\n"
<<"matrix<real> A = elast(Vh,Vh);			// Assembly for A\n"
<<"real[int]    b = elast(0,Vh);			// Assembly for b\n"
<<"set(A,solver=CG);				// Solver setup\n"
<<"u[]=A^-1*b;					// Solving\n\n";

if(plotAll){
  system("mkdir -p VTUs");
   
  writevarfmatsolve
  <<"//==============================================================================\n"
  <<"// -------Plotting with paraview-------//\n"
  <<"//==============================================================================\n\n"

  <<"load  \"../Plugins/iovtk\"			// Loading the vtk viz module\n"
  <<"int[int] vtuorder=[1,1,1];			// Solution export order\n"; 
  
  if(spc==2)
     writevarfmatsolve
     <<"savevtk(\"VTUs/Displacements-Seq.vtu\",Th,[u,u1,0],\n"; 
  if(spc==3)
     writevarfmatsolve
     <<"savevtk(\"VTUs/Displacements-Seq.vtu\",Th,[u,u1,u2],\n"; 
  
  writevarfmatsolve       
  <<"		order=vtuorder,dataname=\"Displacement\");";
	  
}

}

}


}
