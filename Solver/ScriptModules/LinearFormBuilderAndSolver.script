//=====================================================================================
// ------ Building the LinearFormBuilderAndSolver.edp file ------ 
//=====================================================================================

{ofstream  writesolver("LinearFormBuilderAndSolver.edp");

writesolver
<<"										   \n"
<<"/**************Variational formulation, solving, & post-proc *******************\n"
<<"*                                                                              *\n"
<<"* Note!!! This file is  generated  by running SolverGenerator.edp. Do not edit *\n"
<<"*         in order to  control this  file please change flag arguments of  the *\n"
<<"*         SolverGenerator, details of which are present in SolverGenerator.edp *\n"
<<"*         or in the README.MD file.                                            *\n"
<<"*                                                                              *\n"
<<"*******************************************************************************/\n"
<<"										   \n"
<<"										   \n";

if(nonlinear){writesolver
<<"										   \n"
<<"//==============================================================================\n"
<<"// ------- Nonlinear parameter calculations -------				   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"										   \n";

if(Sequential)writesolver
<<"//----- Lo calculation ----//						   \n"
<<"										   \n"
<<"{  										   \n"
<<"  fespace  Vh0( Th , P0)    ;						   \n"
<<"  Vh0 size1 = hTriangle     ;						   \n"
<<"  lo = size1[].min          ;						   \n"
<<"  lo = lo*lfac              ;						   \n"
<<"}										   \n"
<<"										   \n"
<<"										   \n"
<<"  matrix  A, A1				;  				   \n"
<<"  real[int]  b(Vh.ndof), b1(Vh1.ndof)	;				   \n"
<<"										   \n"
<<"										   \n";

if(pipegnu){writesolver
<<"  system(\"rm force.data\")      	;					   \n"
<<"										   \n"
<<"  matrix  And			;	// PostProcessing		   \n";

if(vectorial)writesolver
<<"  Vh def(fr) 			;	// Variables for force  	   \n"
<<"										   \n"
<<"  int[int]  ldof( 1 )			;				   \n"
<<"  ExtractDofBorderVectorial(2,Vh,ldof)	;				   \n"
<<"										   \n";

if(!vectorial)writesolver
<<"  Vh def2(fr)			;	// Variables for force  	   \n"
<<"										   \n"
<<"  int[int]  ldof( 1 )		;					   \n"
<<"  ExtractDofBorderP1(2,Vh,ldof)	;					   \n"
<<"										   \n";

if(!supercomp)writesolver
<<"  pstream pgnuplot(\"gnuplot -p\")  	;					   \n";
}

if(debug)if(vectorial)writesolver
<<"										   \n"
<<"  VhPlt phi;									   \n"
<<"										   \n";

if(!Sequential)writesolver
<<"//------------- Lo calculation in parallel -------------//			   \n"
<<"										   \n"
<<"{ real himlocal,himGlobal                                ;			   \n"
<<"  fespace Vh0(Th,P0)                                     ;			   \n"
<<"  Vh0 size1 = hTriangle                                  ;			   \n"
<<"  himlocal  = size1[].min                                ;			   \n"
<<"  mpiAllReduce(himlocal,himGlobal,mpiCommWorld,mpiMIN)   ;			   \n"
<<"  lo = himGlobal*lfac                                    ;			   \n"
<<"}										   \n";

if(Sequential){writesolver
<<"										   \n"
<<"										   \n"
<<"//==============================================================================\n"
<<"// ------- Nonlinear loop -------						   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"while (tr <= maxtr){								   \n"
<<"										   \n"
<<"  cout <<  \"  Applied traction \" << tr << endl;				   \n"
<<"										   \n"
<<"  if (tr >= 5e-3)								   \n"
<<"    dtr = 1e-6;								   \n"
<<"										   \n"
<<(timelog ? "  timerbegin(\"RHS Assembly U\",t0)\n" : "" 	          	    )
<<"  b = elast(0,Vh);				// Assembly for b (once / NL loop) \n"
<<(timelog ? "  timerend  (\"RHS Assembly U\",t0)\n" : ""  	         	    )
<<"										   \n"
<<"										   \n"
<<"  for(int iter=0; iter<100; iter++){					   	   \n"
<<"										   \n"
<<(timelog ? "    timerbegin(\"Matrix Assembly U\",t0)\n" : ""	           	    )
<<"    A = elast(Vh,Vh);				// Assembly for A (for u)   \n"
<<(timelog ? "    timerend  (\"Matrix Assembly U\",t0)\n" : ""	           	    )
<<(timelog ? "    timerbegin(\"Solving U\",t0)\n"         : ""         	  	    )
//<<"    set(A,solver=UMFPACK);				// Solver setup	   	   \n"
<<"    u[] = A^-1*b;				// Solve u	   		   \n"
<<(timelog ? "    timerend  (\"Solving U\",t0)\n"         : ""         	  	    )
<<"										   \n"
<<"										   \n"
<<(timelog ? "    timerbegin(\"Matrix Assembly PHI\",t0)\n" : ""           	    )
<<"    A1 = phase(Vh1,Vh1);			// Assembly for A1 (for phi)  	   \n"
<<(timelog ? "    timerend  (\"Matrix Assembly PHI\",t0)\n" : ""           	    )
<<(timelog ? "    timerbegin(\"RHS Assembly PHI\",t0)\n" : "" 	          	    )
<<"    b1 = phase(0,Vh1);				// Assembly for b (for phi)\n"
<<(timelog ? "    timerend  (\"RHS Assembly U\",t0)\n" : ""  	         	    )
<<(timelog ? "    timerbegin(\"Solving U\",t0)\n" : "" 	        	  	    )
//<<"    set(A1,solver=UMFPACK);			// Solver setup	   \n"
<<"    phi[] = A1^-1*b1;				// Solve	   	   \n"
<<(timelog ? "    timerend  (\"Solving U\",t0)\n" : "" 	        	  	    )
<<"										   \n"
<<"										   \n"
<<"    uold[]    = uold[]-u[]                         ;				   \n"
<<"    phiold[]  = phiold[]-phi[]                     ;				   \n"
<<"    real err1 = sqrt( intN(Th) ( uold^2   )  )     ;				   \n"
<<"    real err2 = sqrt( intN(Th) ( phiold^2 )  )     ;				   \n"
<<"										   \n"
<<"    cout.scientific << \" Iter \" << iter<< \"  error in u \"<< err1		   \n"
<<"                    <<\"  error in phi \"<< err2 << endl;			   \n"
<<"										   \n"
<<"										   \n"
<<"    phiold[] = phi[]  ;							   \n"
<<"    uold[]   = u[]    ;							   \n"
<<"										   \n"
<<"    if(err1 < 1e-2 && err2 < 1e-2){						   \n"
<<"										   \n";

if(pipegnu)writesolver
<<"										   \n"
<<"      And = elastNoDirc(Vh,Vh);						   \n"
<<"      fr[] = And*u[];							   \n"
<<"										   \n"
<<"      real forcetot  = 0. ; 							   \n"
<<"      for(int i = 0; i < ldof.n; ++i)					   \n"
<<"        forcetot = forcetot + fr1[][ldof[i]];				   \n"
<<"										   \n"
<<"      { ofstream ff(\"force.data\",append);				  	   \n"
<<"        ff << tr << \"	\" << forcetot*1e-3 << endl; 			   \n"
<<"      }									   \n"
<<"										   \n"
<<"										   \n"
<<"      { 							   	   	   \n"
<<"	   pgnuplot <<\"set title  \\\"Traction = \"+tr+\"\\\"	;\\n\";    	   \n"
<<"	   pgnuplot <<\"set termoption font \\\"Arial-Bold,20\\\";\\n\";  	   \n"
<<"	   pgnuplot <<\"set format x \\\"%.1t\\\"		;\\n\";    	   \n"
<<"	   pgnuplot <<\"set grid x y 				;\\n\";    	   \n"
<<"	   pgnuplot <<\"set xrange [0:.008] 			;\\n\";    	   \n"
<<"	   pgnuplot <<\"set yrange [0:.9] 			;\\n\";    	   \n"
<<"	   pgnuplot <<\"set xlabel \\\" Displacement \\\"	;\\n\";	   	   \n"
<<"	   pgnuplot <<\"set ylabel \\\" Force (kN)\\\"		;\\n\";    	   \n"
<<"	   pgnuplot <<\"set key left 				;\\n\";    	   \n"
<<"	   pgnuplot <<\"plot					\" 	   	   \n"
<<"		    <<\"    \\\"force.data\\\"			\" 	   	   \n"
<<"		    <<\"	   u 1:2 w lp pt 6 ps 2 t \\\"   FEM\\\",\"  	   \n"
<<"		    <<\"     \\\"ambati.data\\\"		\" 	  	   \n"
<<"		    <<\"	   u 1:2 w lp lt -1 pt 4 ps 2  t \\\"Ref\\\"\"	   \n"
<<"		    <<\"					\\n\"; 	   	   \n" 
<<"        flush(pgnuplot);					   	   	   \n"
<<"       }							  	   	   \n"
<<"									   	   \n"
<<"									   	   \n";

writesolver
<<"										   \n"
<<"      cout.scientific << \" Solution converged after \"       		   \n"
<<"                      <<  iter << endl;					   \n";

if(debug)writesolver
<<"										   \n"	
<<"      plot(phi,fill=1,value=1);				  		   \n";

writesolver
<<"										   \n"	
<<"      break;							   		   \n"
<<"    }									   \n"
<<"  } 										   \n"
<<"	tr+ = dtr;								   \n"
<<"}										   \n"
<<"										   \n"	
<<"										   \n"
<<"										   \n";

}  //-- [if loop terminator] Sequential ended --//

if(!Sequential){writesolver
<<"										   \n"
<<"										   \n"	  
<<"//==============================================================================\n"
<<"// ------- Sparsity conservation -------					   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"										   \n"
<<"  varf DUMMY(uu,vv) = intN(Th,qforder = 1)(uu*vv)                      ;	   \n"
<<"  matrix  MatDUMMY  = DUMMY(Vh, Vh)                                    ;	   \n"
<<"  Mat  A( MatDUMMY, arrayIntersectionP, restrictionIntersectionP, DP)  ; 	   \n"
<<"  MatDUMMY.resize(0,0)                                                 ;	   \n";

if(!vectorial)writesolver
<<"										   \n"
<<"  matrix	 MatDUMMY1 = DUMMY(Vh1, Vh1);					   \n"
<<"  Mat A1(MatDUMMY1, arrayIntersectionZ, restrictionIntersectionZ, DZ);  	   \n"
<<"  MatDUMMY1.resize(0,0);							   \n"
<<"										   \n"
<<"  matrix     ALoc, ALoc1                 ;  // Local matrices for bilinear	   \n"
<<"  real[int]  b(Vh.ndof), b1(Vh1.ndof)    ;  // Local vectors for  linear	   \n";

if(vectorial)writesolver
<<"										   \n"
<<"  matrix     ALoc           ;        // Local vectorial matrix for bilinear	   \n"
<<"  real[int]  b(Vh.ndof)     ;        // Local vectorial real vector for linear  \n";

if(pipegnu)writesolver
<<"										   \n"
<<"  matrix	 MatDUMMY2 = DUMMY(Vh, Vh);					   \n"
<<"  Mat A2(MatDUMMY2, arrayIntersectionP, restrictionIntersectionP, DP);  	   \n"
<<"  MatDUMMY2.resize(0,0);							   \n"
<<"										   \n";

writesolver
<<"										   \n"
<<"										   \n"
<<"//==============================================================================\n"
<<"// -------Nonlinear loop-------						   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"										   \n";

if(plotAll)writesolver
<<"										   \n"
<<" //------Plotting--------//							   \n"
<<"  exportBegin(\"VTUs/Solution\", mpiCommWorld);				   \n"
<<"  int iterout = 0;				      // Loop Counter		   \n"
<<"										   \n";

writesolver
<<"										   \n"
<<"while (tr <= maxtr){								   \n"
<<"										   \n"
<<"  if(mpirank==0)cout <<  \"  Applied traction \" << tr << endl;		   \n"
<<"										   \n"
<<"  if (tr >= 5e-3)								   \n"
<<"    dtr = 1e-6;								   \n"
<<"										   \n"
<<(timelog ? "  MPItimerbegin(\"RHS Assembly U\",t0)\n" : ""           	            )
<<"  b = elast(0,Vh);				// Assembly linear	 	   \n"
<<(timelog ? "  MPItimerend  (\"RHS Assembly U\",t0)\n" : ""           	  	    )
<<"										   \n"
<<"  for(int iter=0; iter<100; iter++){					   	   \n"
<<"										   \n"
<<(timelog ? "    MPItimerbegin(\"Matrix Assembly U\",t0)\n" : ""           	    )
<<"    ALoc = elast(Vh,Vh);			// Assembly bilinear	  	   \n"
<<(timelog ? "    MPItimerend  (\"Matrix Assembly U\",t0)\n" : ""           	    )
<<"										   \n"
<<"										   \n"
<<(timelog ? "    MPItimerbegin(\"PETSc Assembly U\",t0)\n" : ""           	    )
<<"    changeOperator(A, ALoc);				   	   		   \n"
<<"    set(A,sparams =\" \");			// Solver setup		   	   \n"
<<(timelog ? "    MPItimerend  (\"PETSc Assembly U\",t0)\n" : ""       	  	    )
<<"										   \n"
<<(timelog ? "    MPItimerbegin(\"Solving U\",t0)\n" : " "         	  	    )
<<"    u[] = A^-1*b;	                         // Solve u			   \n"
<<(timelog ? "    MPItimerend  (\"Solving U\",t0)\n" : " "           	  	    )
<<"										   \n";

if(!vectorial)writesolver
<<"										   \n"
<<(timelog ? "    MPItimerbegin(\"Matrix Assembly PHI\",t0)\n" : ""           	    )
<<"    ALoc1 = phase(Vh1,Vh1);		// Assembly bilinear	   		   \n"
<<(timelog ? "    MPItimerend  (\"Matrix Assembly PHI\",t0)\n" : ""    	  	    )
<<"										   \n"
<<(timelog ? "    MPItimerbegin(\"RHS Assembly PHI\",t0)\n" : ""           	    )
<<"    b1 = phase(0,Vh1);	// Assembly linear	   			   \n"
<<(timelog ? "    MPItimerend  (\"RHS Assembly PHI\",t0)\n" : ""           	    )
<<"										   \n"
<<(timelog ? "    MPItimerbegin(\"PETSc Assembly PHI\",t0)\n" : ""           	    )
<<"    changeOperator(A1, ALoc1);					  	   \n"
<<"    set(A1,sparams =\" \");		// Solver setup		   		   \n"
<<(timelog ? "    MPItimerend  (\"PETSc Assembly PHI\",t0)\n" : ""           	    )
<<"										   \n"
<<(timelog ? "    MPItimerbegin(\"Solving PHI\",t0)\n" : ""    		       	    )
<<"    phi[] = A1^-1*b1;		// Solve phi	  	   		   \n"
<<(timelog ? "    MPItimerend  (\"Solving PHI\",t0)\n" : ""           	  	    )
<<"										   \n"
<<"    uold[]   = uold[]-u[]		;					   \n"
<<"    phiold[] = phiold[]-phi[]	; 					   \n"
<<"										   \n"
<<"    uold[]     .*= DP		;					   \n"
<<"    phiold[]   .*= DZ		;					   \n"
<<"										   \n"
<<"										   \n"
<<"    real err1Gather,err2Gather;						   \n"
<<"    real err1Loc=sqrt( intN(Th) ( (uold)^2 )  );				   \n"
<<"    real err2Loc=sqrt( intN(Th) ( (phiold)^2 )  );				   \n"
<<"										   \n"
<<"    mpiAllReduce(err1Loc,err1Gather,mpiCommWorld,mpiSUM);			   \n"
<<"    mpiAllReduce(err2Loc,err2Gather,mpiCommWorld,mpiSUM);			   \n"
<<"										   \n"
<<"    if(mpirank==0)							      	   \n"
<<"      cout.scientific << \" Iter \" << iter << \"  error in u \"	   	   \n"
<<"      << err1Gather <<\" error in phi \"<< err2Gather << endl;	   	   \n"
<<"										   \n"
<<"										   \n"
<<"    phiold[]=phi[];							   	   \n"
<<"    uold[]=u[];							   	   \n"
<<"										   \n"
<<"										   \n"
<<"    if(err1Gather < 1e-2 && err2Gather < 1e-2){			   	   \n"
<<"										   \n"
<<"										   \n"
<<"      if(mpirank==0)						   		   \n"
<<"        cout  << \" Solution converged after \" << iter << endl;	           \n"
<<"										   \n";


if(vectorial){writesolver
<<"										   \n"
<<"    uold[]   = uold[]-u[]    ;						   \n"
<<"    uold[] .*= DP            ;						   \n"
<<"										   \n";

if(plotAll || debug)writesolver
<<"    phi = u"+spc+";								   \n";

writesolver
<<"										   \n"
<<"										   \n"
<<"    real err1Gather                                          ;		   \n"
<<"    real err1Loc=sqrt( intN(Th) ( (uold)^2 )  )              ;		   \n"
<<"    mpiAllReduce(err1Loc,err1Gather,mpiCommWorld,mpiSUM)     ;		   \n"
<<"										   \n"
<<"    if(mpirank==0)							      	   \n"
<<"      cout.scientific << \" Iteration :  \" << iter 		   		   \n"
<<"      << \" L2 error in [u,phi] \" << err1Gather << endl;			   \n"
<<"    									   	   \n"
<<"    uold[] = u[];							   	   \n"
<<"										   \n"
<<"										   \n"
<<"    if(err1Gather < 1e-2){						   	   \n"
<<"										   \n"
<<"      if(mpirank==0)						   		   \n"
<<"        cout  << \" Solution converged after \" << iter << endl;	           \n"
<<"										   \n";

}  //-- [if loop terminator] vectorial ended --//

if(pipegnu){writesolver
<<"	And = elastNoDirc(Vh,Vh);						   \n"
<<"	changeOperator(A2, And);						   \n"
<<"	fr[] = And*u[];								   \n"
<<"										   \n"
<<"	fr[] .*= DP;								   \n"
<<"										   \n"
<<"	real forcetot  = 0.,forcetotGath  = 0. ;				   \n"
<<"		for(int i = 0; i < ldof.n; ++i)					   \n"
<<"		forcetot = forcetot + fr1[][ldof[i]];				   \n"
<<"										   \n"
<<"	mpiAllReduce(forcetot,forcetotGath,mpiCommWorld,mpiSUM);		   \n"
<<"										   \n"
<<"	if(mpirank==0){								   \n"
<<"	{ ofstream ff(\"force.data\",append);					   \n"
<<"		ff << tr << \"	\" << forcetotGath*1e-3 << endl;		   \n"
<<"	}									   \n"
<<"										   \n"
<<"										   \n";

if(!supercomp)writesolver
<<"										   \n"
<<"										   \n"
<<"      { 							   	   	   \n"
<<"	   pgnuplot <<\"set title  \\\"Traction = \"+tr+\"\\\"	;\\n\";    	   \n"
<<"	   pgnuplot <<\"set termoption font \\\"Arial-Bold,20\\\";\\n\";  	   \n"
<<"	   pgnuplot <<\"set format x \\\"%.1t\\\"		;\\n\";    	   \n"
<<"	   pgnuplot <<\"set grid x y 				;\\n\";    	   \n"
<<"	   pgnuplot <<\"set xrange [0:.008] 			;\\n\";    	   \n"
<<"	   pgnuplot <<\"set yrange [0:.9] 			;\\n\";    	   \n"
<<"	   pgnuplot <<\"set xlabel \\\" Displacement \\\"	;\\n\";	   	   \n"
<<"	   pgnuplot <<\"set ylabel \\\" Force (kN)\\\"		;\\n\";    	   \n"
<<"	   pgnuplot <<\"set key left 				;\\n\";    	   \n"
<<"	   pgnuplot <<\"plot					\" 	   	   \n"
<<"		    <<\"    \\\"force.data\\\"			\" 	   	   \n"
<<"		    <<\"	   u ($1):($2) w lp pt 6 ps 2 t \\\"   FEM\\\",\"  \n"
<<"		    <<\"     \\\"ambati.data\\\"		\" 	  	   \n"
<<"		    <<\"	   u ($1):($2) w lp lt 5 pt 4 ps 2  t \\\"Ref\\\"\"\n"
<<"		    <<\"					\\n\"; 	   	   \n" 
<<"        flush(pgnuplot);					   	   	   \n"
<<"       }							  	   	   \n";

writesolver
<<"										   \n"
<<"	  }								   	   \n"
<<"									   	   \n";
}  //-- [if loop terminator] !pipegnu ended --//

if(plotAll)if(!vectorial)writesolver
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"Post-Processing\",t0)\n" : ""           	    )
<<"      exportTimeStep2(\"VTUs/Solution\",Th, 		   			   \n"
<<(spc==2 ? "      \t[u,u1,0],phi,\n" : "      \t[u,u1,u2],phi,\n" 	    	    )
<<"      iterout, mpiCommWorld);			   			   \n"
<<(timelog ? "	MPItimerend  (\"Post-Processing\",t0)\n" : ""       	    	    )
<<"										   \n";

if(plotAll)if(vectorial)writesolver
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"Post-Processing\",t0)\n" : ""           	    )
<<"      exportTimeStep2(\"VTUs/Solution\",Th, 		   			   \n"
<<(spc==2 ? "      \t[u,u1,0],u2,\n" : "      \t[u,u1,u2],u3,\n" 	    	    )
<<"      iterout, mpiCommWorld);			   			   \n"
<<(timelog ? "	MPItimerend  (\"Post-Processing\",t0)\n" : ""       	    	    )
<<"										   \n";

if(debug)if(!vectorial)writesolver
<<"										   \n"				
<<"      plotMPI(Th, phi[],\"Tr-\"+tr+\"\", Zk, def, real, 2, 0)		   \n"
<<"										   \n";

if(debug)if(vectorial)writesolver
<<"										   \n"				
<<"      plotMPI(Th, phi[],\"Tr-\"+tr+\"\", Pltk, def0, real, 2, 0)		   \n"
<<"										   \n";

writesolver
<<"      break;									   \n"
<<"    }									   \n"
<<"  } 									  	   \n"
<<"  tr += dtr;									   \n"
<<"}										   \n"
<<"										   \n"	
<<"										   \n";

}  //-- [if loop terminator] !Sequential ended --//
 
}  //-- [if loop terminator] nonlinear ended --//

if(!nonlinear){

if(!Sequential){writesolver      
<<"										   \n"	
<<"//==============================================================================\n"
<<"//  -------Local Au=b assembly and solving-------				   \n"
<<"//==============================================================================\n"	
<<"										   \n"
<<"										   \n"
<<"//-----------------Assembly for A-----------------//				   \n"
<<"										   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"Matrix Assembly\",t0)\n" : " "           	    )
<<"  matrix	ALoc = elast(Vh,Vh);		// Assembly bilinear		   \n"
<<(timelog ? "	MPItimerend  (\"Matrix Assembly\",t0)\n" : " "       	    	    )
<<"										   \n"
<<"										   \n"
<<"//-----------------Assembly for b-----------------//				   \n"
<<"										   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"RHS Assembly\",t0)\n" : " "          	 	    )
<<"	real[int]    b = elast(0,Vh);			// Assembly linear	   \n"
<<(timelog ? "	MPItimerend  (\"RHS Assembly\",t0)\n" : " "       	    	    )
<<"										   \n";

if(pointbc)writesolver
<<"										   \n"
<<"//---------Additional assembly for A & b----------//				   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"Point Dirichlet Assembly\",t0)\n" : " "  	    )
<<"  Pointbc(Dpointlab,Vh,ALoc,b,PnV);			// Assembly linear	   \n"
<<(timelog ? "	MPItimerend(\"Point Dirichlet Assembly\",t0)\n" : " "        	    )
<<"										   \n";

writesolver
<<"										   \n"
<<" //------------Memory optimization-----------------//			   \n"
<<"										   \n";

if(pointbc)writesolver
<<"										   \n"
<<"  Dpointlab.resize(0); PnV.resize(0);					   \n"
<<"										   \n";

if(dirichletbc)writesolver
<<"										   \n"
<<"  Dlabel.resize(0); Dvalue.resize(0);					   \n"
<<"										   \n";

if(tractionbc)writesolver
<<"										   \n"
<<"  Tlabel.resize(0);								   \n"
<<"										   \n"; 
   
writesolver
<<"										   \n"
<<"//---------------PETSc Assembly---------------------//			   \n"
<<"										   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"PETSc Assembly\",t0)\n" : " "  	    		   )
<<"      Mat A				// Distributed matrix 		   	   \n"
<<"		  ( ALoc			, 				   \n"
<<"		    arrayIntersectionP		,				   \n"
<<"                 restrictionIntersectionP	,				   \n"
<<" 		    DP				,				   \n"
<<" 		    bs = "+spc+" 						   \n"
<<"		  );								   \n"
<<(timelog ? "	MPItimerend(\"PETSc Assembly\",t0)\n" : " "  	    		   )
<<"										   \n"
<<"										   \n"
<<"//------------PETSc solving------------------//				   \n"
<<"										   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"PETSc Solving\",t0)\n" : " "  	    		   )
<<"      Vh<real> def(u);							   \n"
<<"      set(A,sparams =\" \");            // Solver setup-Petsc		   \n"
<<"      u[] = A^-1*b;                     // Solving				   \n"
<<"										   \n"
<<(timelog ? "	MPItimerend(\"PETSc Solving\",t0)\n" : " "  	    		   )
<<"										   \n"       
<<"										   \n";

}  //-- [if loop terminator] !Sequential ended --//

if(Sequential){writesolver    
<<"										   \n"	
<<"//==============================================================================\n"
<<"//  -------Local Au=b assembly and solving-------				   \n"
<<"//==============================================================================\n"	
<<"										   \n"
<<(timelog ? "	timerbegin(\"Matrix Assembly\",t0)\n" : " "  	    		   )
<<"		matrix<real> A = elast(Vh,Vh);		// Assembly for A	   \n"
<<(timelog ? "	timerend  (\"Matrix Assembly\",t0)\n" : " "  	    		   )
<<(timelog ? "	timerbegin(\"RHS Assembly\",t0)\n" : " "  	    		   )
<<"		real[int]    b = elast(0,Vh);		// Assembly for b	   \n"
<<(timelog ? "	timerend  (\"RHS Assembly\",t0)\n" : " "  	    		   )
<<(timelog ? "	timerbegin(\"Solving U\",t0)\n" : " "  	    		   	   )
<<"		set(A,solver=CG);			// Solver setup		   \n"
<<"		u[] = A^-1*b;				// Solving		   \n"
<<(timelog ? "	timerend  (\"Solving U\",t0)\n" : " "  	   	 		   )
<<"										   \n"
<<"										   \n";

}  //-- [if loop terminator] Sequential ended --//

}  //-- [if loop terminator] !nonlinear ended --//

if(!plotAll)if(!Sequential)writesolver
<<"										   \n"
<<(timelog ? "   MPItimerend(\"Solver\",t1)\n" : ""  	         	  	    )
<<"										   \n";

if(!plotAll)if(Sequential)writesolver
<<"										   \n"
<<(timelog ? "   timerend(\"Solver\",t1)\n" : ""  	         	  	    )
<<"										   \n";


} //-- [ostream terminator]  varfmatsolve.edp closed --//
