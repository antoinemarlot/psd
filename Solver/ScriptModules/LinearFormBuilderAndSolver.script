//=====================================================================================
// ------ Building the LinearFormBuilderAndSolver.edp file ------ 
//=====================================================================================

{ofstream  writesolver("LinearFormBuilderAndSolver.edp");

writesolver
<<"										   \n"
<<"/**************Variational formulation, solving, & post-proc *******************\n"
<<"*                                                                              *\n"
<<"* Note!!! This file is  generated  by running SolverGenerator.edp. Do not edit *\n"
<<"*         in order to  control this  file please change flag arguments of  the *\n"
<<"*         SolverGenerator, details of which are present in SolverGenerator.edp *\n"
<<"*         or in the README.MD file.                                            *\n"
<<"*                                                                              *\n"
<<"*******************************************************************************/\n"
<<"										   \n"
<<"										   \n";

if(nonlinear){writesolver
<<"										   \n"
<<"//==============================================================================\n"
<<"// -------Nonlinear parameter calulations-------				   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"										   \n";

if(Sequential)writesolver
<<"										   \n"
<<"{  										   \n"
<<"  fespace  Vh0( Th , P0) ;							   \n"
<<"    Vh0 size1=hTriangle  ;							   \n"
<<"										   \n"
<<"  lo = size1[].min       ;							   \n"
<<"  lo = lo*lfac           ;							   \n"
<<"}										   \n"
<<"										   \n"
<<"										   \n"
<<"  matrix  A, A1				;  				   \n"
<<"  real[int]  b(Vh.ndof), b1(Vh1.ndof)	;				   \n"
<<"										   \n"
<<"										   \n";

if(pipegnu){writesolver
<<"  system(\"rm force.data\")      	;					   \n"
<<"										   \n"
<<"  matrix  And			;	// PostProcessing		   \n"
<<"										   \n"
<<"  Vh def2(fr)			;	// P1 Variables for force  	   \n"
<<"										   \n"
<<"  int[int]  ldof( 1 )		;					   \n"
<<"  ExtractDofBorderP1(2,Vh,ldof)	;					   \n"
<<"										   \n";

if(!supercomp)writesolver
<<"  pstream pgnuplot(\"gnuplot -p\")  	;					   \n";
}

if(debug)if(vectorial)writesolver
<<"										   \n"
<<"  VhPlt phi;									   \n"
<<"										   \n";

if(!Sequential)writesolver
<<"										   \n"
<<"{										   \n"
<<" real himlocal,himGlobal;							   \n"
<<" fespace Vh0(Th,P0);								   \n"
<<" Vh0 size1=hTriangle;							   \n"
<<" himlocal=size1[].min;							   \n"
<<"										   \n"
<<" mpiAllReduce(himlocal,himGlobal,mpiCommWorld,mpiMIN);			   \n"
<<"										   \n"
<<" lo=himGlobal*lfac;								   \n"
<<"}										   \n"
<<"										   \n";

if(Sequential){writesolver
<<"										   \n"
<<"										   \n"
<<"//==============================================================================\n"
<<"// -------Nonlinear loop-------						   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"while (tr <= maxtr){								   \n"
<<"										   \n"
<<"  cout <<  \"  Applied traction \" << tr <<endl;				   \n"
<<"										   \n"
<<"  if (tr >=5e-3)								   \n"
<<"    dtr = 1e-6;								   \n"
<<"										   \n"
<<(timelog ? "  timerbegin(\"RHS Assembly U\",t0)\n" : "" 	          	    )
<<"  b = elast(0,Vh);				// Assembly for b (once / NL loop) \n"
<<(timelog ? "	timerend  (\"RHS Assembly U\",t0)\n" : ""  	         	    )
<<"										   \n"
<<"										   \n"
<<"  for(int iter=0; iter<100; iter++){					   	   \n"

<<(timelog ? "	timerbegin(\"Matrix Assembly U\",t0)\n" : ""	           	    )
<<"    A = elast(Vh,Vh);				// Assembly for A   	   \n"
<<(timelog ? "	timerend  (\"Matrix Assembly U\",t0)\n" : ""	           	    )
<<(timelog ? "	timerbegin(\"Solving U\",t0)\n"         : ""         	  	    )
//<<"    set(A,solver=UMFPACK);				// Solver setup	   	   \n"
<<"    u[]=A^-1*b;					// Solve	   	   \n"
<<(timelog ? "	timerend  (\"Solving U\",t0)\n"         : ""         	  	    )
<<"										   \n"
<<"										   \n"
<<(timelog ? "	timerbegin(\"Matrix Assembly PHI\",t0)\n" : ""           	    )
<<"    A1 = phase(Vh1,Vh1);				// Assembly for A   \n"
<<(timelog ? "	timerend  (\"Matrix Assembly PHI\",t0)\n" : ""           	    )
<<(timelog ? "	timerbegin(\"RHS Assembly PHI\",t0)\n" : "" 	          	    )
<<"    b1 = phase(0,Vh1);				// Assembly for b   \n"
<<(timelog ? "	timerend  (\"RHS Assembly U\",t0)\n" : ""  	         	    )
<<(timelog ? "	timerbegin(\"Solving U\",t0)\n" : "" 	        	  	    )
//<<"    set(A1,solver=UMFPACK);			// Solver setup	   \n"
<<"    phi[]=A1^-1*b1;				// Solve	   \n"
<<(timelog ? "	timerend  (\"Solving U\",t0)\n" : "" 	        	  	    )
<<"										   \n"
<<"										   \n"
<<"    uold[]=uold[]-u[];							   \n"
<<"    phiold[]=phiold[]-phi[]; 						   \n"
<<"    real err1=sqrt( intN(Th) ( (uold)^2 )  );				   \n"
<<"    real err2=sqrt( intN(Th) ( (phiold)^2 )  );				   \n"
<<"    cout.scientific << \" Iter \" << iter<< \"  error in u \"<< err1		   \n"
<<"                    <<\"  error in phi \"<< err2<<endl;			   \n"
<<"										   \n"
<<"										   \n"
<<"    phiold[]=phi[];								   \n"
<<"    uold[]=u[];								   \n"
<<"										   \n"
<<"    if(err1 < 1e-2 && err2 < 1e-2){						   \n"
<<"										   \n";

if(pipegnu)writesolver
<<"										   \n"
<<"      And = elastNoDirc(Vh,Vh);						   \n"
<<"      fr[]=And*u[];								   \n"
<<"										   \n"
<<"      real forcetot  = 0. ; 							   \n"
<<"      for(int i = 0; i < ldof.n; ++i)					   \n"
<<"        forcetot = forcetot + fr1[][ldof[i]];				   \n"
<<"										   \n"
<<"      { ofstream ff(\"force.data\",append);				  	   \n"
<<"        ff << tr << \"	\" << forcetot*1e-3 << endl; 			   \n"
<<"      }									   \n"
<<"										   \n"
<<"										   \n"
<<"      { 							   	   	   \n"
<<"	   pgnuplot <<\"set title  \\\"Traction = \"+tr+\"\\\"	;\\n\";    	   \n"
<<"	   pgnuplot <<\"set termoption font \\\"Arial-Bold,20\\\";\\n\";  	   \n"
<<"	   pgnuplot <<\"set format x \\\"%.1t\\\"		;\\n\";    	   \n"
<<"	   pgnuplot <<\"set grid x y 				;\\n\";    	   \n"
<<"	   pgnuplot <<\"set xrange [0:.008] 			;\\n\";    	   \n"
<<"	   pgnuplot <<\"set yrange [0:.9] 			;\\n\";    	   \n"
<<"	   pgnuplot <<\"set xlabel \\\" Displacement \\\"	;\\n\";	   	   \n"
<<"	   pgnuplot <<\"set ylabel \\\" Force (kN)\\\"		;\\n\";    	   \n"
<<"	   pgnuplot <<\"set key left 				;\\n\";    	   \n"
<<"	   pgnuplot <<\"plot					\" 	   	   \n"
<<"		    <<\"    \\\"force.data\\\"			\" 	   	   \n"
<<"		    <<\"	   u 1:2 w lp pt 6 ps 2 t \\\"   FEM\\\",\"  	   \n"
<<"		    <<\"     \\\"ambati.data\\\"		\" 	  	   \n"
<<"		    <<\"	   u 1:2 w lp lt -1 pt 4 ps 2  t \\\"Ref\\\"\"	   \n"
<<"		    <<\"					\\n\"; 	   	   \n" 
<<"        flush(pgnuplot);					   	   	   \n"
<<"       }							  	   	   \n"
<<"									   	   \n"
<<"									   	   \n";

writesolver
<<"										   \n"
<<"      cout.scientific << \" Solution converged after \"       		   \n"
<<"                      <<  iter << endl;					   \n";

if(debug)writesolver
<<"										   \n"	
<<"      plot(phi,fill=1,value=1);				  		   \n";

writesolver
<<"										   \n"	
<<"      break;							   		   \n"
<<"    }									   \n"
<<"  } 										   \n"
<<"	tr+=dtr;								   \n"
<<"}										   \n"
<<"										   \n"	
<<"										   \n"
<<"										   \n";

}  //-- [if loop terminator] Sequential ended --//

if(!Sequential){writesolver
<<"										   \n"
<<"										   \n"	  
<<"//==============================================================================\n"
<<"// -------Sparsity conservation-------					   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"										   \n"
<<"  varf DUMMY(uu,vv) =intN(Th,qforder=1)(uu*vv);				   \n"
<<"										   \n"
<<"  matrix	 MatDUMMY = DUMMY(Vh, Vh);					   \n"
<<"  Mat A(MatDUMMY, arrayIntersectionP, restrictionIntersectionP, DP);	 	   \n"
<<"  MatDUMMY.resize(0,0);							   \n";

if(!vectorial)writesolver
<<"										   \n"
<<"  matrix	 MatDUMMY1 = DUMMY(Vh1, Vh1);					   \n"
<<"  Mat A1(MatDUMMY1, arrayIntersectionZ, restrictionIntersectionZ, DZ);  	   \n"
<<"  MatDUMMY1.resize(0,0);							   \n"
<<"										   \n"
<<"  matrix     ALoc, ALoc1			;				   \n"
<<"  real[int]  b(Vh.ndof), b1(Vh1.ndof)	;				   \n";

if(vectorial)writesolver
<<"										   \n"
<<"  matrix     ALoc				;				   \n"
<<"  real[int]  b(Vh.ndof)			;				   \n";

if(pipegnu)writesolver
<<"										   \n"
<<"  matrix	 MatDUMMY2 = DUMMY(Vh, Vh);					   \n"
<<"  Mat A2(MatDUMMY2, arrayIntersectionP, restrictionIntersectionP, DP);  	   \n"
<<"  MatDUMMY2.resize(0,0);							   \n"
<<"										   \n";

writesolver
<<"										   \n"
<<"										   \n"
<<"//==============================================================================\n"
<<"// -------Nonlinear loop-------						   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"										   \n";

if(plotAll)writesolver
<<"										   \n"
<<" //------Plotting--------//							   \n"
<<"  exportBegin(\"VTUs/Solution\", mpiCommWorld);				   \n"
<<"  int iterout=0;				      // Loop Counter		   \n"
<<"										   \n";

writesolver
<<"										   \n"
<<"while (tr <= maxtr){								   \n"
<<"										   \n"
<<"  if(mpirank==0)cout <<  \"  Applied traction \" << tr <<endl;		   \n"
<<"										   \n"
<<"  if (tr >=5e-3)								   \n"
<<"    dtr = 1e-6;								   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"RHS Assembly U\",t0)\n" : ""           	            )
<<"    b = elast(0,Vh);				// Assembly linear	 	   \n"
<<(timelog ? "	MPItimerend(\"RHS Assembly U\",t0)\n" : " "           	  	    )
<<"										   \n"
<<"										   \n"
<<"  for(int iter=0; iter<100; iter++){					   	   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"Matrix Assembly U\",t0)\n" : " "           	    )
<<"    ALoc = elast(Vh,Vh);			// Assembly bilinear	  	   \n"
<<(timelog ? "	MPItimerend(\"Matrix Assembly U\",t0)\n" : " "           	    )
<<"										   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"PETSc Assembly U\",t0)\n" : " "           	    )
<<"    changeOperator(A, ALoc);				   	   		   \n"
<<"    set(A,sparams =\" \");			// Solver setup		   	   \n"
<<(timelog ? "	MPItimerend(\"PETSc Assembly U\",t0)\n" : " "          	  	    )
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"Solving U\",t0)\n" : " "         	  	    )
<<"    u[]=A^-1*b;				// Solve u			   \n"
<<(timelog ? "	MPItimerend(\"Solving U\",t0)\n" : " "           	  	    )
<<"										   \n";

if(!vectorial)writesolver
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"Matrix Assembly PHI\",t0)\n" : " "           	    )
<<"    ALoc1 = phase(Vh1,Vh1);		// Assembly bilinear	   		   \n"
<<(timelog ? "	MPItimerend(\"Matrix Assembly PHI\",t0)\n" : " "       	  	    )
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"RHS Assembly PHI\",t0)\n" : " "           	    )
<<"    b1 = phase(0,Vh1);	// Assembly linear	   \n"
<<(timelog ? "	MPItimerend(\"RHS Assembly PHI\",t0)\n" : " "           	    )
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"PETSc Assembly PHI\",t0)\n" : " "           	    )
<<"    changeOperator(A1, ALoc1);					  	   \n"
<<"    set(A1,sparams =\" \");		// Solver setup		   		   \n"
<<(timelog ? "	MPItimerend(\"PETSc Assembly PHI\",t0)\n" : " "           	    )
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"Solving PHI\",t0)\n" : " "    		       	    )
<<"    phi[]=A1^-1*b1;			// Solve phi	  	   		   \n"
<<(timelog ? "	MPItimerend(\"Solving PHI\",t0)\n" : " "           	  	    )
<<"										   \n"
<<"										   \n"
<<"    uold[]   = uold[]-u[]		;					   \n"
<<"    phiold[] = phiold[]-phi[]	; 					   \n"
<<"										   \n"
<<"    uold[]     .*= DP		;					   \n"
<<"    phiold[]   .*= DZ		;					   \n"
<<"										   \n"
<<"										   \n"
<<"    real err1Gather,err2Gather;						   \n"
<<"    real err1Loc=sqrt( intN(Th) ( (uold)^2 )  );				   \n"
<<"    real err2Loc=sqrt( intN(Th) ( (phiold)^2 )  );				   \n"
<<"										   \n"
<<"    mpiAllReduce(err1Loc,err1Gather,mpiCommWorld,mpiSUM);			   \n"
<<"    mpiAllReduce(err2Loc,err2Gather,mpiCommWorld,mpiSUM);			   \n"
<<"										   \n"
<<"    if(mpirank==0)							      	   \n"
<<"      cout << \" Iter \" << iter<< \"  error in u \"			   	   \n"
<<"           << err1Gather <<\" error in phi \"<< err2Gather<<endl;	   	   \n"
<<"										   \n"
<<"										   \n"
<<"    phiold[]=phi[];							   	   \n"
<<"    uold[]=u[];							   	   \n"
<<"										   \n"
<<"										   \n"
<<"    if(err1Gather < 1e-2 && err2Gather < 1e-2){			   	   \n"
<<"										   \n"
<<"										   \n"
<<"      if(mpirank==0)						   		   \n"
<<"        cout.scientific << \" Solution converged after \"		           \n"
<<"                        <<  iter <<endl;					   \n"
<<"										   \n";


if(vectorial)writesolver
<<"										   \n"
<<"    phi=u"+spc+";								   \n"
<<"										   \n"
<<"    uold[]   = uold[]-u[]		;					   \n"
<<"										   \n"
<<"    uold[]     .*= DP		;					   \n"
<<"										   \n"
<<"    real err1Gather;								   \n"
<<"    real err1Loc=sqrt( intN(Th) ( (uold)^2 )  );				   \n"
<<"										   \n"
<<"    mpiAllReduce(err1Loc,err1Gather,mpiCommWorld,mpiSUM);			   \n"
<<"										   \n"
<<"    if(mpirank==0)							      	   \n"
<<"      cout << \" Iter \" << iter<< \"  error in (u,phi) \"		   	   \n"
<<"           << err1Gather << endl;	   	  				   \n"
<<"    									   	   \n"
<<"    uold[]=u[];							   	   \n"
<<"										   \n"
<<"										   \n"
<<"    if(err1Gather < 1e-2){						   	   \n"
<<"										   \n"
<<"      if(mpirank==0)						   		   \n"
<<"        cout.scientific << \" Solution converged after \"		           \n"
<<"                        <<  iter <<endl;					   \n"
<<"										   \n";

if(pipegnu){writesolver
<<"	And = elastNoDirc(Vh,Vh);						   \n"
<<"	changeOperator(A2, And);						   \n"
<<"	fr[]=And*u[];								   \n"
<<"										   \n"
<<"	fr[].*= DP;								   \n"
<<"										   \n"
<<"	real forcetot  = 0.,forcetotGath  = 0. ;				   \n"
<<"		for(int i = 0; i < ldof.n; ++i)					   \n"
<<"		forcetot = forcetot + fr1[][ldof[i]];				   \n"
<<"										   \n"
<<"	mpiAllReduce(forcetot,forcetotGath,mpiCommWorld,mpiSUM);		   \n"
<<"										   \n"
<<"	if(mpirank==0){								   \n"
<<"	{ ofstream ff(\"force.data\",append);					   \n"
<<"		ff << tr << \"	\" << forcetotGath*1e-3 << endl;		   \n"
<<"	}									   \n"
<<"										   \n"
<<"										   \n";

if(!supercomp)writesolver
<<"										   \n"
<<"										   \n"
<<"      { 							   	   	   \n"
<<"	   pgnuplot <<\"set title  \\\"Traction = \"+tr+\"\\\"	;\\n\";    	   \n"
<<"	   pgnuplot <<\"set termoption font \\\"Arial-Bold,20\\\";\\n\";  	   \n"
<<"	   pgnuplot <<\"set format x \\\"%.1t\\\"		;\\n\";    	   \n"
<<"	   pgnuplot <<\"set grid x y 				;\\n\";    	   \n"
<<"	   pgnuplot <<\"set xrange [0:.008] 			;\\n\";    	   \n"
<<"	   pgnuplot <<\"set yrange [0:.9] 			;\\n\";    	   \n"
<<"	   pgnuplot <<\"set xlabel \\\" Displacement \\\"	;\\n\";	   	   \n"
<<"	   pgnuplot <<\"set ylabel \\\" Force (kN)\\\"		;\\n\";    	   \n"
<<"	   pgnuplot <<\"set key left 				;\\n\";    	   \n"
<<"	   pgnuplot <<\"plot					\" 	   	   \n"
<<"		    <<\"    \\\"force.data\\\"			\" 	   	   \n"
<<"		    <<\"	   u ($1):($2) w lp pt 6 ps 2 t \\\"   FEM\\\",\"  \n"
<<"		    <<\"     \\\"ambati.data\\\"		\" 	  	   \n"
<<"		    <<\"	   u ($1):($2) w lp lt 5 pt 4 ps 2  t \\\"Ref\\\"\"\n"
<<"		    <<\"					\\n\"; 	   	   \n" 
<<"        flush(pgnuplot);					   	   	   \n"
<<"       }							  	   	   \n";

writesolver
<<"										   \n"
<<"	  }								   	   \n"
<<"									   	   \n";
}  //-- [if loop terminator] !pipegnu ended --//

if(plotAll)if(!vectorial)writesolver
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"Post-Processing\",t0)\n" : ""           	    )
<<"      exportTimeStep2(\"VTUs/Solution\",Th, 		   			   \n"
<<(spc==2 ? "      \t[u,u1,0],phi,\n" : "      \t[u,u1,u2],phi,\n" 	    	    )
<<"      iterout, mpiCommWorld);			   			   \n"
<<(timelog ? "	MPItimerend  (\"Post-Processing\",t0)\n" : ""       	    	    )
<<"										   \n";

if(plotAll)if(vectorial)writesolver
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"Post-Processing\",t0)\n" : ""           	    )
<<"      exportTimeStep2(\"VTUs/Solution\",Th, 		   			   \n"
<<(spc==2 ? "      \t[u,u1,0],u2,\n" : "      \t[u,u1,u2],u3,\n" 	    	    )
<<"      iterout, mpiCommWorld);			   			   \n"
<<(timelog ? "	MPItimerend  (\"Post-Processing\",t0)\n" : ""       	    	    )
<<"										   \n";

if(debug)if(!vectorial)writesolver
<<"										   \n"				
<<"      plotMPI(Th, phi[],\"Tr-\"+tr+\"\", Zk, def, real, 2, 0)		   \n"
<<"										   \n";

if(debug)if(vectorial)writesolver
<<"										   \n"				
<<"      plotMPI(Th, phi[],\"Tr-\"+tr+\"\", Pltk, def0, real, 2, 0)		   \n"
<<"										   \n";

writesolver
<<"			break;							   \n"
<<"		}								   \n"
<<"	} 									   \n"
<<"	tr+=dtr;								   \n"
<<"}										   \n"
<<"										   \n"	
<<"										   \n";

}  //-- [if loop terminator] !Sequential ended --//
 
}  //-- [if loop terminator] nonlinear ended --//

if(!nonlinear){

if(!Sequential){writesolver      
<<"										   \n"	
<<"//==============================================================================\n"
<<"//  -------Local Au=b assembly and solving-------				   \n"
<<"//==============================================================================\n"	
<<"										   \n"
<<"										   \n"
<<"//-----------------Assembly for A-----------------//				   \n"
<<"										   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"Matrix Assembly\",t0)\n" : " "           	    )
<<"  matrix	ALoc = elast(Vh,Vh);		// Assembly bilinear		   \n"
<<(timelog ? "	MPItimerend  (\"Matrix Assembly\",t0)\n" : " "       	    	    )
<<"										   \n"
<<"										   \n"
<<"//-----------------Assembly for b-----------------//				   \n"
<<"										   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"RHS Assembly\",t0)\n" : " "          	 	    )
<<"	real[int]    b = elast(0,Vh);			// Assembly linear	   \n"
<<(timelog ? "	MPItimerend  (\"RHS Assembly\",t0)\n" : " "       	    	    )
<<"										   \n";

if(pointbc)writesolver
<<"										   \n"
<<"//---------Additional assembly for A & b----------//				   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"Point Dirichlet Assembly\",t0)\n" : " "  	    )
<<"  Pointbc(Dpointlab,Vh,ALoc,b,PnV);			// Assembly linear	   \n"
<<(timelog ? "	MPItimerend(\"Point Dirichlet Assembly\",t0)\n" : " "        	    )
<<"										   \n";

writesolver
<<"										   \n"
<<" //------------Memory optimization-----------------//			   \n"
<<"										   \n";

if(pointbc)writesolver
<<"										   \n"
<<"  Dpointlab.resize(0); PnV.resize(0);					   \n"
<<"										   \n";

if(dirichletbc)writesolver
<<"										   \n"
<<"  Dlabel.resize(0); Dvalue.resize(0);					   \n"
<<"										   \n";

if(tractionbc)writesolver
<<"										   \n"
<<"  Tlabel.resize(0);								   \n"
<<"										   \n"; 
   
writesolver
<<"										   \n"
<<"//---------------PETSc Assembly---------------------//			   \n"
<<"										   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"PETSc Assembly\",t0)\n" : " "  	    		   )
<<"      Mat A				// Distributed matrix 		   	   \n"
<<"		  ( ALoc			, 				   \n"
<<"		    arrayIntersectionP		,				   \n"
<<"                 restrictionIntersectionP	,				   \n"
<<" 		    DP				,				   \n"
<<" 		    bs = "+spc+" 						   \n"
<<"		  );								   \n"
<<(timelog ? "	MPItimerend(\"PETSc Assembly\",t0)\n" : " "  	    		   )
<<"										   \n"
<<"										   \n"
<<"//------------PETSc solving------------------//				   \n"
<<"										   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"PETSc Solving\",t0)\n" : " "  	    		   )
<<"      Vh<real> def(u);							   \n"
<<"      set(A,sparams =\" \");            // Solver setup-Petsc		   \n"
<<"      u[]=A^-1*b;                       // Solving				   \n"
<<"										   \n"
<<(timelog ? "	MPItimerend(\"PETSc Solving\",t0)\n" : " "  	    		   )
<<"										   \n"       
<<"										   \n";

}  //-- [if loop terminator] !Sequential ended --//

if(Sequential){writesolver    
<<"										   \n"	
<<"//==============================================================================\n"
<<"//  -------Local Au=b assembly and solving-------				   \n"
<<"//==============================================================================\n"	
<<"										   \n"
<<(timelog ? "	timerbegin(\"Matrix Assembly\",t0)\n" : " "  	    		   )
<<"		matrix<real> A = elast(Vh,Vh);		// Assembly for A	   \n"
<<(timelog ? "	timerend  (\"Matrix Assembly\",t0)\n" : " "  	    		   )
<<(timelog ? "	timerbegin(\"RHS Assembly\",t0)\n" : " "  	    		   )
<<"		real[int]    b = elast(0,Vh);		// Assembly for b	   \n"
<<(timelog ? "	timerend  (\"RHS Assembly\",t0)\n" : " "  	    		   )
<<(timelog ? "	timerbegin(\"Solving U\",t0)\n" : " "  	    		   	   )
<<"		set(A,solver=CG);			// Solver setup		   \n"
<<"		u[]=A^-1*b;				// Solving		   \n"
<<(timelog ? "	timerend  (\"Solving U\",t0)\n" : " "  	   	 		   )
<<"										   \n"
<<"										   \n";

}  //-- [if loop terminator] Sequential ended --//

}  //-- [if loop terminator] !nonlinear ended --//

} //-- [ostream terminator]  varfmatsolve.edp closed --//
