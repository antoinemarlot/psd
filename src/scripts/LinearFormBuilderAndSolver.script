//=====================================================================================
// ------ Building the LinearFormBuilderAndSolver.edp file ------ 
//=====================================================================================

{ofstream  writesolver("LinearFormBuilderAndSolver.edp");

writesolver
<<"										   \n"
<<"/**************Variational formulation, solving, & post-proc *******************\n"
<<"*                                                                              *\n"
<<"* Note!!! This file is  generated  by running SolverGenerator.edp. Do not edit *\n"
<<"*         in order to  control this  file please change flag arguments of  the *\n"
<<"*         SolverGenerator, details of which are present in SolverGenerator.edp *\n"
<<"*         or in the README.MD file.                                            *\n"
<<"*                                                                              *\n"
<<"*******************************************************************************/\n"
<<"										   \n";

if(nonlinear){

if(Sequential)writesolver
<<"										   \n"
<<"//==============================================================================\n"
<<"// ------- L_o calculation -------						   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"{  										   \n"
<<"  fespace  Vh0( Th , P0)    ;						   \n"
<<"  Vh0 size1 = hTriangle     ;						   \n"
<<"  lo = size1[].min          ;						   \n"
<<"  lo = lo*lfac              ;						   \n"
<<"}										   \n";

/************************OLD METHOD*************************************************
if(pipegnu)if(!supercomp)writesolver
<<"										   \n"
<<"  matrix  And			;	// PostProcessing		   \n";
if(vectorial)writesolver
<<"  Vh def(fr) 			;	// Variables for force  	   \n"
<<"										   \n"
<<"  int[int]  ldof( 1 )			;				   \n"
<<"  ExtractDofBorderVectorial(2,Vh,ldof)	;				   \n"
<<"										   \n";

if(!vectorial)writesolver
<<"  Vh def2(fr)			;	// Variables for force  	   \n"
<<"										   \n"
<<"  int[int]  ldof( 1 )		;					   \n"
<<"  ExtractDofBorderP1(2,Vh,ldof)	;					   \n"
<<"										   \n";
/************************OLD METHOD*************************************************/ 

if(!Sequential)writesolver
<<"										   \n"
<<"//==============================================================================\n"
<<"// ------- L_o calculation in parallel -------				   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"{ real himlocal,himGlobal                                ;			   \n"
<<"  fespace Vh0(Th,P0)                                     ;			   \n"
<<"  Vh0 size1 = hTriangle                                  ;			   \n"
<<"  himlocal  = size1[].min                                ;			   \n"
<<"  mpiAllReduce(himlocal,himGlobal,mpiCommWorld,mpiMIN)   ;			   \n"
<<"  lo = himGlobal*lfac                                    ;			   \n"
<<"}										   \n";


if(Sequential){writesolver
<<"										   \n"
<<"//==============================================================================\n"
<<"// ------- Traction loading loop -------					   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"while (tr <= maxtr){								   \n"
<<"										   \n"
<<"  cout <<  \"-------------------------------------------------------\\n\" 	   \n"
<<"       <<  \"Applied traction \" << tr << \"\\n\" << endl;			   \n"
<<"										   \n"
<<"  if (tr >= 5e-3)								   \n"
<<"    dtr = 1e-6;								   \n"
<<"										   \n"
<<(timelog ? "  timerbegin(\"RHS assembly for U\",t0)\n" : "" 	          	    )
<<"  b = elast(0,Vh);				// Assembly for b (once / NL loop) \n"
<<(timelog ? "  timerend  (\"RHS assembly for U\",t0)\n" : ""  	         	    )
<<"										   \n"
<<"										   \n"
<<"  for(int iter=0; iter<100; iter++){					   	   \n"
<<"										   \n"
<<(timelog ? "    timerbegin(\"matrix assembly for U\",t0)\n" : ""	       	    )
<<"    A = elast(Vh,Vh);				// Assembly for A (for u)   \n"
<<(timelog ? "    timerend  (\"matrix assembly for U\",t0)\n" : ""	            )
<<"										   \n"
<<"										   \n"
<<(timelog ? "    timerbegin(\"Solving U\",t0)\n"         : ""         	  	    )
<<"    set(A,solver=CG);				// Solver setup	   	   \n"
<<"    u[] = A^-1*b;				// Solve u	   		   \n"
<<(timelog ? "    timerend  (\"Solving U\",t0)\n"         : ""         	  	    )
<<"										   \n"
<<"										   \n"
<<(energydecomp ? "    DecomposeElasticEnergy(Hplus,Hminus,H)\n"  : "\n"  	    )
<<"										   \n"
<<"										   \n"
<<(timelog ? "    timerbegin(\"matrix assembly for PHI\",t0)\n" : ""           	    )
<<"    A1 = phase(Vh1,Vh1);			// Assembly for A1 (for phi)  	   \n"
<<(timelog ? "    timerend  (\"matrix assembly for PHI\",t0)\n" : ""           	    )
<<"										   \n"
<<"										   \n"
<<(timelog ? "    timerbegin(\"RHS assembly for PHI\",t0)\n" : "" 	            )
<<"    b1 = phase(0,Vh1);				// Assembly for b (for phi)\n"
<<(timelog ? "    timerend  (\"RHS assembly for U\",t0)\n" : ""  	            )
<<"										   \n"
<<"										   \n"
<<(timelog ? "    timerbegin(\"Solving U\",t0)\n" : "" 	        	  	    )
<<"    set(A1,solver=CG);			// Solver setup	   \n"
<<"    phi[] = A1^-1*b1;				// Solve	   	   \n"
<<(timelog ? "    timerend  (\"Solving U\",t0)\n" : "" 	        	  	    )
<<"										   \n"
<<"										   \n"
<<"    uold[]    = uold[]-u[]                         ;				   \n"
<<"    phiold[]  = phiold[]-phi[]                     ;				   \n"
<<"    real err1 = sqrt( intN(Th,qforder=3) ( uold^2   )  )     ;		   \n"
<<"    real err2 = sqrt( intN(Th,qforder=3) ( phiold^2 )  )     ;		   \n"
<<"										   \n"
<<"      cout.scientific << \"NL iteration number :  [ \"  << iter 	   	   \n"
<<"      << \" ]\\nL2 error in [u,phi] :  [ \"    << err1  			   \n"
<<"      << \" , \" <<  err2 << \" ]\"      << endl;	   			   \n"
<<"										   \n"
<<"    phiold[] = phi[]  ;							   \n"
<<"    uold[]   = u[]    ;							   \n"
<<"										   \n"
<<"    if(err1 < 1e-2 && err2 < 1e-2){						   \n"
<<"										   \n";

if(pipegnu)writesolver
<<"										   \n"
<<"	real forcetot  = 0.;							   \n"
<<"	forcetot = intN1(Th,qforder=3,2)(lambda*divergence(u)+2.*mu*dy(u1));	   \n"
<<"										   \n"       
/************************OLD METHOD*************************************************   
<<"      And = elastNoDirc(Vh,Vh);						   \n"
<<"      fr[] = And*u[];							   \n"
<<"										   \n"
<<"      real forcetot  = 0. ; 							   \n"
<<"      for(int i = 0; i < ldof.n; ++i)					   \n"
<<"        forcetot = forcetot + fr1[][ldof[i]];				   \n"
/************************OLD METHOD*************************************************/
<<"										   \n"
<<"      { ofstream ff(\"force.data\",append);				  	   \n"
<<"        ff << tr << \"	\" << forcetot*1e-3 << endl; 			   \n"
<<"      }									   \n"
<<"										   \n"
<<"										   \n"
<<"      { 							   	   	   \n"
<<"	   pgnuplot <<\"plot \\\"force.data\\\"u 1:2 w lp pt 6 ps 2 t \\\"FEM\\\"\"\n"
//<<"		    <<\",\\\"ambati.data\\\"u 1:2 w p pt 4 ps 2  t \\\"Ref\\\"\"   \n"
<<"        flush(pgnuplot);					   	   	   \n"
<<"       }							  	   	   \n";

writesolver
<<"										   \n"
<<"      cout.scientific << \" Solution converged after \"       		   \n"
<<"                      <<  iter << endl;					   \n";

if(debug)writesolver
<<"										   \n"	
<<"      plot(phi,fill=1,value=1);				  		   \n";

writesolver
<<"										   \n"	
<<"      break;							   		   \n"
<<"    }									   \n"
<<"  } 										   \n"
<<"	tr += dtr;								   \n"
<<"}										   \n";

}  //-- [if loop terminator] Sequential ended --//

if(!Sequential){writesolver
<<"										   \n"
<<"//==============================================================================\n"
<<"// -------  Traction loading loop  -------					   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"while (tr <= maxtr){								   \n"
<<"										   \n"
<<"  if(mpirank==0)								   \n"
<<"  cout.scientific<<\"-----------------------------------------------------\\n\" \n"
<<"  <<  \"Applied traction \" << tr << \"\\n\" << endl;	   		   \n"
<<"										   \n"
<<"  if (tr >= 5e-3)								   \n"
<<"    dtr = 1e-6;								   \n"
<<"										   \n"
<<"  //--------------------Assembly for linear----------------------//		   \n"
<<"										   \n"
<<(timelog ? "  MPItimerbegin(\"RHS assembly for U\",t0)\n" : ""       	            )
<<"  b = elast(0,Vh);							 	   \n"
<<(timelog ? "  MPItimerend  (\"RHS assembly for U\",t0)\n" : ""       	  	    )
<<"										   \n"
<<"  //-----------------------Nonlinear loop------------------------//		   \n"
<<"										   \n"
<<"  for(int iter=0; iter<100; iter++){					   	   \n"
<<"										   \n"
<<"    //----------------Assembly for bilinear----------------------//	 	   \n"
<<"										   \n"
<<(timelog ? "    MPItimerbegin(\"matrix assembly for U\",t0)\n" : ""         	    )
<<"    ALoc = elast(Vh,Vh);						  	   \n"
<<(timelog ? "    MPItimerend  (\"matrix assembly for U\",t0)\n" : ""          	    )
<<"										   \n"
<<"    //-----------PETSc assembly for bilinear---------------------//		   \n"
<<"										   \n"
<<(timelog ? "    MPItimerbegin(\"PETSc assembly for U\",t0)\n" : ""           	    )
<<"    changeOperator(A, ALoc);				   	   		   \n"
<<"    set(A,sparams =\" \");						   	   \n"
<<(timelog ? "    MPItimerend  (\"PETSc assembly for U\",t0)\n" : ""   	  	    )
<<"										   \n"
<<"    //-------------Linear system solving phase-------------------//		   \n"
<<"										   \n"
<<(timelog ? "    MPItimerbegin(\"solving U\",t0)\n" : " "         	  	    )
<<"    u[] = A^-1*b;	                         				   \n"
<<(timelog ? "    MPItimerend  (\"solving U\",t0)\n" : " "           	  	    )
<<"										   \n";

if(!vectorial){
if(energydecomp)writesolver
<<"										   \n"
<<"    //---------------Energy decomposition phase-------------------//	  	   \n"
<<"										   \n"
<<"    DecomposeElasticEnergy(Hplus,Hminus,H);					   \n";

writesolver
<<"										   \n"
<<"    //----------------Assembly for bilinear----------------------//	 	   \n"
<<"										   \n"
<<(timelog ? "    MPItimerbegin(\"matrix assembly for PHI\",t0)\n" : ""        	    )
<<"    ALoc1 = phase(Vh1,Vh1);		// Assembly bilinear	   		   \n"
<<(timelog ? "    MPItimerend  (\"matrix assembly PHI\",t0)\n" : ""    	  	    )
<<"										   \n"
<<"    //----------------Assembly for linear------------------------//	 	   \n"
<<"										   \n"
<<(timelog ? "    MPItimerbegin(\"RHS assembly for PHI\",t0)\n" : ""           	    )
<<"    b1 = phase(0,Vh1);	// Assembly linear	   			   \n"
<<(timelog ? "    MPItimerend  (\"RHS assembly for PHI\",t0)\n" : ""           	    )
<<"										   \n"
<<"    //-----------PETSc assembly for bilinear---------------------//		   \n"
<<"										   \n"
<<(timelog ? "    MPItimerbegin(\"PETSc assembly for PHI\",t0)\n" : ""         	    )
<<"    changeOperator(A1, ALoc1);					  	   \n"
<<"    set(A1,sparams =\" \");					   		   \n"
<<(timelog ? "    MPItimerend  (\"PETSc assembly for PHI\",t0)\n" : ""         	    )
<<"										   \n"
<<"    //-------------Linear system solving phase-------------------//		   \n"
<<"										   \n"
<<(timelog ? "    MPItimerbegin(\"solving PHI\",t0)\n" : ""    		       	    )
<<"    phi[] = A1^-1*b1;		// Solve phi	  	   		   \n"
<<(timelog ? "    MPItimerend  (\"solving PHI\",t0)\n" : ""           	  	    )
<<"										   \n"
<<"    //------------------Error calculation------------------------//		   \n"
<<"										   \n"
<<"    uold[]   = uold[]-u[]		;					   \n"
<<"    phiold[] = phiold[]-phi[]	; 					   \n"
<<"										   \n"
<<"    real err1Gather,err2Gather;						   \n"
<<"    real err1Loc=sqrt( intN(Th,qforder=3) ( DPspc*(uold)^2   )  );		   \n"
<<"    real err2Loc=sqrt( intN(Th,qforder=3) ( DZspc*(phiold)^2 )  );		   \n"
<<"										   \n"
<<"    mpiAllReduce(err1Loc,err1Gather,mpiCommWorld,mpiSUM);			   \n"
<<"    mpiAllReduce(err2Loc,err2Gather,mpiCommWorld,mpiSUM);			   \n"
<<"										   \n"
<<"    if(mpirank==0)							      	   \n"
<<"    cout.scientific << \"NL iteration number :  [ \"  << iter 	   	   \n"
<<"    << \" ]\\nL2 error in [u,phi] :  [ \"    << err1Gather  		 	   \n"
<<"    << \" , \" <<  err2Gather << \" ]\"      << endl;	   		   \n"
<<"										   \n"
<<"    //--------------------Solution update-------------------------//		   \n"
<<"										   \n"
<<"    phiold[]=phi[];							   	   \n"
<<"    uold[]=u[];							   	   \n"
<<"										   \n"
<<"    if(err1Gather < 1e-2 && err2Gather < 1e-2){			   	   \n";
}

if(vectorial){writesolver
<<"										   \n"
<<"    //------------------Error calculation------------------------//		   \n"
<<"										   \n"
<<"    uold[]   = uold[]-u[]    ;						   \n";

writesolver
<<"										   \n"
<<"    real err1Gather                                                ;		   \n"
<<"    real err1Loc=sqrt( intN(Th,qforder=3) ( DPspc*(uold)^2 )  )    ;		   \n"
<<"    mpiAllReduce(err1Loc,err1Gather,mpiCommWorld,mpiSUM)           ;		   \n"
<<"										   \n"
<<"    if(mpirank==0)							      	   \n"
<<"    cout.scientific << \"NL iteration number :  [ \" << iter    		   \n"
<<"    << \" ]\\nL2  error  in  [U]  :  [ \" << err1Gather << \" ]\" <<endl;	   \n"
<<"										   \n"
<<"    //--------------------Solution update-------------------------//		   \n"
<<"										   \n"
<<"    uold[] = u[];							   	   \n";

if(energydecomp)writesolver
<<"										   \n"
<<"    //---------------Energy decomposition phase-------------------//	  	   \n"
<<"										   \n"
<<"    DecomposeElasticEnergy(Hplus,Hminus,H);					   \n";

writesolver
<<"										   \n"
<<"    //--------------- Convergence conditional---------------------//	  	   \n"
<<"										   \n"
<<"    if(err1Gather < 1e-2){						   	   \n";

}  //-- [if loop terminator] vectorial ended --//


/************************OLD METHOD*************************************************
if(pipegnu){writesolver
<<"										   \n"
<<"      //-------------------Force calculation-----------------------//	   \n"
<<"										   \n"
<<"	And = elastNoDirc(Vh,Vh);						   \n"
<<"	changeOperator(A2, And);						   \n"
<<"	fr[] = And*u[];								   \n"
<<"										   \n"
<<"	fr[] .*= DP;								   \n"
<<"										   \n"
<<"	real forcetot  = 0.,forcetotGath  = 0. ;				   \n"
<<"		for(int i = 0; i < ldof.n; ++i)					   \n"
<<"		forcetot = forcetot + fr1[][ldof[i]];				   \n"
<<"										   \n"
/************************OLD METHOD*************************************************/


if(pipegnu){writesolver
<<"										   \n"
<<"      //-------------------Force calculation-----------------------//	   \n"
<<"										   \n"
<<"      real forcetot  = 0., forcetotGath  = 0. ;				   \n"
<<"      forcetot=intN1(Th,qforder=3,2)(DPspc*(lambda*divergence(u)+2.*mu*dy(u1)));\n"
<<"										   \n"
<<"      mpiAllReduce(forcetot,forcetotGath,mpiCommWorld,mpiSUM);		   \n"
<<"										   \n"
<<"      //----------------Writing force to a file--------------------//	   \n"
<<"										   \n"
<<"      if(mpirank==0){							   \n"
<<"										   \n"
<<"        ofstream ff(\"force.data\",append);					   \n"
<<"        ff << tr << \"	\" << forcetotGath*1e-3 << endl;		   \n";

if(!supercomp)writesolver
<<"										   \n"
<<"        //--------------------Gnuplot pipeing----------------------//	   \n"
<<"										   \n"
<<"        pgnuplot 								   \n"
<<"        <<\"plot \\\"force.data\\\" u 1:2 w lp pt 6 ps 2 t \\\" FEM\\\"\\n\";   \n"
//<<"      <<\",\\\"ambati.data\\\"u 1:2 w p pt 4 ps 2  t \\\"Ref\\\"\"   	   \n"
<<"        flush(pgnuplot);					   	   	   \n";

writesolver
<<"										   \n"
<<"	  }								   	   \n";

}  //-- [if loop terminator] !pipegnu ended --//

if(plotAll)if(!vectorial)writesolver
<<"										   \n"
<<"      iterout++;								   \n"
<<"										   \n"
<<"      if(int(iterout%10)==0){						   \n"
<<"										   \n"
<<"        //-----------------Paraview plotting----------------------//  	   \n"
<<"										   \n"
<<(timelog ? "        MPItimerbegin(\"post-processing\",t0)\n" : ""           	    )
<<"										   \n"
<<"        string   namevtu=\"VTUs/Solution\"+iterout1+\"\";			   \n"
<<"        exportpvd2(  namevtu            , 					   \n"
<<"                     Th                 ,				   	   \n"
<<(spc==2 ? "\t\t     [u,u1,0]\t\t,\n" : "\t\t     [u,u1,u2]\t\t,\n" 	   	    )
<<"                     phi                ,				   	   \n"
<<"                     vtuorder           ,				   	   \n"
<<"                     withsur            ,				   	   \n"
<<"                     namedata           ,				   	   \n"
<<"                     mpiCommWorld       				   	   \n"
<<"                  );			       				   	   \n"
<<"										   \n"
<<(timelog ? "        MPItimerend  (\"post-processing\",t0)\n" : ""    	    	    )
<<"        iterout1++;								   \n"
<<"	}									   \n"
<<"										   \n";

if(plotAll || debug)if(vectorial)writesolver
<<"										   \n"
<<"      //---------------Interploation for phi--------------------//	  	   \n"
<<"										   \n"
<<"      phi = u"+spc+";							   \n";

if(plotAll)if(vectorial)writesolver
<<"										   \n"
<<"      iterout++;								   \n"
<<"										   \n"
<<"      //--------Paraview plotting every nth iteration ----------//  	   	   \n"
<<"										   \n"
<<"      if(int(iterout%10)==0){						   \n"
<<"										   \n"
<<(timelog ? "        MPItimerbegin(\"post-processing\",t0)\n" : ""           	    )
<<"										   \n"
<<"        string   namevtu=\"VTUs/Solution\"+iterout1+\"\";			   \n"
<<"        exportpvd2(  namevtu            , 					   \n"
<<"                     Th                 ,				   	   \n"
<<(spc==2 ? "\t\t     [u,u1,0]\t\t,\n" : "\t\t     [u,u1,u2]\t\t,\n" 	   	    )
<<"                     phi                ,				   	   \n"
<<"                     vtuorder           ,				   	   \n"
<<"                     withsur            ,				   	   \n"
<<"                     namedata           ,				   	   \n"
<<"                     mpiCommWorld       				   	   \n"
<<"                  );			       				   	   \n"
<<"										   \n"
<<(timelog ? "        MPItimerend  (\"post-processing\",t0)\n" : ""    	    	    )
<<"										   \n"
<<"        iterout1++;								   \n"
<<"      }									   \n";

if(debug)if(!vectorial)writesolver
<<"										   \n"
<<"      //-----------------Debug glut plotting----------------------//  	   \n"
<<"										   \n"
<<"      plotMPI(Th, phi[],\"Tr-\"+tr+\"\", Zk, def, real, 2, 0)		   \n";

if(debug)if(vectorial)writesolver
<<"										   \n"
<<"      //-----------------Debug glut plotting----------------------//  	   \n"
<<"										   \n"
<<"      plotMPI(Th, phi[],\"Tr-\"+tr+\"\", Pltk, def0, real, 2, 0)		   \n";

writesolver
<<"										   \n"
<<"      break;									   \n"
<<"    }									   \n"
<<"  } 									  	   \n"
<<"  tr += dtr;									   \n"
<<"}										   \n"
<<"										   \n"	
<<"										   \n";

}  //-- [if loop terminator] !Sequential ended --//
 
}  //-- [if loop terminator] nonlinear ended --//

if(!nonlinear){

if(!Sequential)if(!dynamic){writesolver      
<<"										   \n"	
<<"//==============================================================================\n"
<<"//  ------- Local Au=b assembly and solving -------				   \n"
<<"//==============================================================================\n"	
<<"										   \n"
<<"//-----------------Assembly for A-----------------//				   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"matrix Assembly\",t0)\n" : " "           	    )
<<"  matrix	ALoc = elast(Vh,Vh);						   \n"
<<(timelog ? "	MPItimerend  (\"matrix Assembly\",t0)\n" : " "       	    	    )
<<"										   \n"
<<"//-----------------Assembly for b-----------------//				   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"RHS assembly\",t0)\n" : " "          	 	    )
<<"	real[int]    b = elast(0,Vh);						   \n"
<<(timelog ? "	MPItimerend  (\"RHS assembly\",t0)\n" : " "       	    	    )
<<"										   \n";

if(pointbc)writesolver
<<"										   \n"
<<"//---------Additional assembly for A & b----------//				   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"point Dirichlet assembly\",t0)\n" : " "  	    )
<<"  Pointbc(Dpointlab,Vh,ALoc,b,PnV);						   \n"
<<(timelog ? "	MPItimerend(\"point Dirichlet assembly\",t0)\n" : " "        	    )
<<"										   \n";

writesolver
<<"										   \n"
<<" //------------Memory optimization-----------------//			   \n"
<<"										   \n";

if(pointbc)writesolver
<<"										   \n"
<<"  Dpointlab.resize(0); PnV.resize(0);					   \n"
<<"										   \n";

if(dirichletbc)writesolver
<<"										   \n"
<<"  Dlabel.resize(0); Dvalue.resize(0);					   \n"
<<"										   \n";

if(tractionbc)writesolver
<<"										   \n"
<<"  Tlabel.resize(0);								   \n"
<<"										   \n"; 
   
writesolver
<<"										   \n"
<<"//---------------PETSc Assembly---------------------//			   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"PETSc assembly\",t0)\n" : " "  	    		   )
<<"      Mat A						 		   	   \n"
<<"		  ( ALoc			, 				   \n"
<<"		    arrayIntersectionP		,				   \n"
<<"                 restrictionIntersectionP	,				   \n"
<<" 		    DP				,				   \n"
<<" 		    bs = "+spc+" 						   \n"
<<"		  );								   \n"
<<(timelog ? "	MPItimerend(\"PETSc assembly\",t0)\n" : " "  	    		   )
<<"										   \n"
<<"//------------PETSc solving------------------//				   \n"
<<"										   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"PETSc solving\",t0)\n" : " "  	    		   )
<<"      Vh<real> def(u);							   \n"
<<"      set(A,sparams =\" \");            					   \n"
<<"      u[] = A^-1*b;                     					   \n"
<<"										   \n"
<<(timelog ? "	MPItimerend(\"PETSc solving\",t0)\n" : " "  	    		   )
<<"										   \n";

}  //-- [if loop terminator] !Sequential ended --//

if(Sequential)if(!dynamic){writesolver    
<<"										   \n"	
<<"//==============================================================================\n"
<<"//  -------Local Au=b assembly and solving-------				   \n"
<<"//==============================================================================\n"	
<<"										   \n"
<<"  Vh  def(u)   ;	// Defining vectorial FE variables 			   \n"
<<"										   \n"
<<"  //-----------------Assembly for A-----------------//			   \n"
<<"										   \n"
<<(timelog ? "	timerbegin(\"matrix assembly\",t0)\n" : " "  	    		   )
<<"		matrix<real> A = elast(Vh,Vh);		// Assembly for A	   \n"
<<(timelog ? "	timerend  (\"matrix assembly\",t0)\n" : " "  	    		   )
<<"										   \n"
<<"  //-----------------Assembly for b-----------------//			   \n"
<<"										   \n"
<<(timelog ? "	timerbegin(\"RHS assembly\",t0)\n" : " "  	    		   )
<<"		real[int]    b = elast(0,Vh);		// Assembly for b	   \n"
<<(timelog ? "	timerend  (\"RHS assembly\",t0)\n" : " "  	    		   )
<<"										   \n"
<<"  //-----------------Solving du=A^-1*b--------------//			   \n"
<<"										   \n"
<<(timelog ? "	timerbegin(\"solving U\",t0)\n" : " "  	    		   	   )
<<"		set(A,solver=CG);			// Solver setup		   \n"
<<"		u[] = A^-1*b;				// Solving		   \n"
<<(timelog ? "	timerend  (\"solving U\",t0)\n" : " "  	   	 		   )
<<"										   \n";

if(debug)writesolver
<<"										   \n"
<<"  //-----------------debug  plotting---------------//			   \n"
<<"										   \n"
<<"  plot (u,wait=0, cmm= \"solution\")  ;				   	   \n";


}  //-- [if loop terminator] Sequential Not Dynamic ended --//


if(Sequential)if(dynamic){writesolver    
<<"										   \n";

writesolver
<<"										   \n"
<<"//==============================================================================\n"
<<"//  ------- Dynamic loop for linear assembly and solving -------		   \n"
<<"//==============================================================================\n"	
<<"										   \n"
<<"while (t <= tmax){								   \n"
<<"										   \n"
<<"  cout.scientific << \"Time iteration at t :\" << t << \" (s) \"<< endl;	   \n"
<<"										   \n"
<<"  //--------------tt update for loading--------------//			   \n"
<<"										   \n"
<<"  tt  = t-real(alpf*dt);                            				   \n"
<<"										   \n"
<<"  //-----------------Assembly for A-----------------//			   \n"
<<"										   \n"
<<(timelog ? "	timerbegin(\"matrix assembly\",t0)\n" : " "  	    		   )
<<"  matrix<real> A = elastodynamics(Vh,Vh,tgv=-1);   			           \n"
<<(timelog ? "	timerend  (\"matrix assembly\",t0)\n" : " "  	    		   )
<<"										   \n"
<<"  //-----------------Assembly for b-----------------//			   \n"
<<"										   \n"
<<(timelog ? "	timerbegin(\"RHS assembly\",t0)\n" : " "  	    		   )
<<"  real[int]    b = elastodynamics(0,Vh,tgv=-1);    			           \n"
<<(timelog ? "	timerend  (\"RHS assembly\",t0)\n" : " "  	    		   )
<<"										   \n"
<<"  //-----------------Solving du=A^-1*b--------------//			   \n"
<<"										   \n"
<<(timelog ? "	timerbegin(\"solving U\",t0)\n" : " "  	    		   	   )
<<"  set(A,solver=UMFPACK);                           				   \n"
<<"   du[] = A^-1*b;                                   				   \n"
<<(timelog ? "	timerend  (\"solving U\",t0)\n" : " "  	   	 		   )
<<"										   \n";

if(debug)if(spc==2)writesolver
<<"										   \n"
<<"  //-----------------Move mesh plotting------------//			   \n"
<<"										   \n"
<<"  meshN ThMoved = movemesh(Th, [x + du, y + du1])  ; 			   \n"
<<"  plot (ThMoved,wait=0, cmm= \"t = \"+t+\" (s)\")  ;				   \n";

if(debug)if(spc==3)writesolver
<<"										   \n"
<<"  //-----------------Move mesh plotting------------//			   \n"
<<"										   \n"
<<"  meshN ThMoved = movemesh3(Th, transfo =[x + du, y + du1, z + du2]) ; 	   \n"
<<"  plot (ThMoved,wait=0, cmm= \"t = \"+t+\" (s)\")  ;				   \n";

writesolver
<<"										   \n"
<<"  //-----------------updating variables------------//			   \n"
<<"										   \n"
<<"  GFPUpdateDynamic(du[],uold[],vold[],aold[],beta,gamma,dt);			   \n";
//<<"  updateVariables(du,uold,vold,aold)					   \n";

if(plotAll)if(spc==2)writesolver
<<"										   \n"
<<"  //-----------------Paraview plotting-------------//			   \n"
<<"										   \n"
<<"  string   namevtu=\"VTUs/Solution\"+iterout+\".vtu\";  		           \n"
<<"  savevtk  (  namevtu               ,					   \n"
<<"              Th                    ,					   \n"
<<"              [uold,uold1,0]        ,					   \n"
<<"              order=vtuorder        ,					   \n"
<<"              dataname=namedata 					    	   \n"
<<"           );  								   \n";


if(plotAll)if(spc==3)writesolver
<<"										   \n"
<<"  //-----------------Paraview plotting-------------//			   \n"
<<"										   \n"
<<"  string   namevtu=\"VTUs/Solution\"+iterout+\".vtu\";  		           \n"
<<"  savevtk  (  namevtu               ,					   \n"
<<"              Th                    ,					   \n"
<<"              [uold,uold1,uold2]    ,					   \n"
<<"              order=vtuorder        ,					   \n"
<<"              dataname=namedata 					    	   \n"
<<"           );  								   \n";


if(pipegnu){writesolver
<<"										   \n"
<<"  //---------------Energy calculations-------------//			   \n"
<<"										   \n"
<<"  Ek =intN(Th,qforder=3)(0.5*(vold*vold+vold1*vold1));			   \n"
<<"  El =intN(Th,qforder=3)(0.5*(lambda*divergence(uold)*divergence(uold) 	   \n"
<<"                         + 2. * mu * epsilon(uold)'*epsilon(uold)) );	   \n"
<<"  Ec += dt*intN(Th,qforder=3)(						   \n"
<<"	                      (etam*rho) *def(vold)'*def(vold)			   \n"
<<"                         + (etak*lambda)*(divergence(vold)*divergence(vold))	   \n"
<<"			    + (etak* 2.*mu)*(epsilon(vold)'*epsilon(vold)) );	   \n"
<<"										   \n"
<<"  //----------Appending energies to a file----------//			   \n"
<<"										   \n"
<<"  ofstream ff(\"energies.data\",append);					   \n"
<<"  ff<< t << \"  \" << Ek << \"  \"<< El << \"  \" << Ec <<endl;		   \n";

if(!supercomp)writesolver
<<"										   \n"
<<"  //-----------------Gnuplot pipeping-------------//				   \n"
<<"										   \n"
<<"  pgnuplot <<\"plot\" 	   						   \n"
<<"  <<\"\\\"energies.data\\\"\" 	   				           \n"
<<"  <<\"u ($1):($2) w lp lw 2 pt 7 ps 2 t \\\"K.E\\\",\" 			   \n"
<<"  <<\"\\\"energies.data\\\"\" 	   	   				   \n"
<<"  <<\"u ($1):($3) w lp lw 2  pt 7 ps 2 t \\\"E.E\\\",\"			   \n"
<<"  <<\"\\\"energies.data\\\"\" 	   	   				   \n"
<<"  <<\"u ($1):($4) w lp lw 2 pt 7 ps 2 t \\\"D.E\\\",\" 			   \n"
<<"  <<\"\\\"energies.data\\\"		\" 	   	   			   \n"
<<"  <<\"u ($1):($3+$2+$4) w lp lw 2 pt 7 ps 2 t \\\"T.E\\\" \"   		   \n"
<<"  <<\"\\n\"; 	   	  						   \n" 
<<"  flush(pgnuplot);					   	  	 	   \n";

}  //-- [if loop terminator]  pipegnu ended --//

writesolver
<<"										   \n"
<<"  //-----------------updating time----------------//				   \n"
<<"										   \n"
<<"  t += dt; 									   \n";

if(plotAll)writesolver
<<"										   \n"
<<"  //-----------updating iteration count-----------//				   \n"
<<"										   \n"
<<"  iterout++;									   \n";

writesolver
<<"										   \n"
<<"}										   \n"
<<"										   \n";

}  //-- [if loop terminator] Sequential Dynamic ended --//


if(!Sequential)if(dynamic){writesolver    
<<"										   \n"
<<"//==============================================================================\n"
<<"//  ------- Dynamic loop for linear assembly and solving -------		   \n"
<<"//==============================================================================\n"	
<<"										   \n"
<<"while (t <= tmax){								   \n"
<<"										   \n"
<<"  if(mpirank==0)								   \n"
<<"  cout.scientific << \"Time iteration at t :\" << t << \" (s) \"<< endl;	   \n"
<<"										   \n"
<<"  //--------------tt update for loading--------------//			   \n"
<<"										   \n"
<<"  tt  = t-real(alpf*dt);                            				   \n"
<<"										   \n"
<<"  //-----------------Assembly for A-----------------//			   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"matrix assembly\",t0)\n" : " "  	    	   )
<<"  ALoc = elastodynamics(Vh,Vh,tgv=-1);   		         	           \n"
<<(timelog ? "	MPItimerend  (\"matrix assembly\",t0)\n" : " "  	    	   )
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"PETSc assembly\",t0)\n" : " "  	    		   )
<<"  changeOperator(A, ALoc);			 				   \n"
<<(timelog ? "	MPItimerend(\"PETSc assembly\",t0)\n" : " "  	    		   )
<<"										   \n"
<<"  //-----------------Assembly for b-----------------//			   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"RHS assembly\",t0)\n" : " "  	    		   )
<<"  b = elastodynamics(0,Vh,tgv=-1);    			           	   \n"
<<(timelog ? "	MPItimerend  (\"RHS assembly\",t0)\n" : " "  	    		   )
<<"										   \n"
<<"  //-----------------Solving du=A^-1*b--------------//			   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"solving U\",t0)\n" : " "  	    	   	   )
<<"  set(A,sparams =\" \");                           				   \n"
<<"   du[] = A^-1*b;                                   				   \n"
<<(timelog ? "	MPItimerend  (\"solving U\",t0)\n" : " "  	   		   )
<<"										   \n";

if(debug)if(spc==2)writesolver
<<"										   \n"
<<"  //-----------------Move mesh plotting------------//			   \n"
<<"										   \n"
<<"  meshN ThMoved = movemesh(Th, [x + du, y + du1]) ; 				   \n"
<<"  plotMPI (ThMoved,du[],\"t = \"+t+\" (s)\",Pk, def, real, 2, 0)  ;		   \n";

if(debug)if(spc==3)writesolver
<<"										   \n"
<<"  //-----------------Move mesh plotting------------//			   \n"
<<"										   \n"
<<"  meshN ThMoved = movemesh3(Th, transfo =[x + du, y + du1, z + du2]) ; 	   \n"
<<"  plotMPI (ThMoved,du[],\"t = \"+t+\" (s)\",Pk, def, real, 3, 0)  ;		   \n";

writesolver
<<"										   \n"
<<"  //-----------------updating variables------------//			   \n"
<<"										   \n"
<<"  GFPUpdateDynamic(du[],uold[],vold[],aold[],beta,gamma,dt);			   \n";
//<<"  updateVariables(du,uold,vold,aold)					   \n";


if(plotAll)if(spc==2)writesolver
<<"										   \n"
<<"  //-----------------ParaView plotting--------------//			   \n"
<<"										   \n"
<<"  string   namevtu=\"VTUs/Solution\"+iterout+\"\";			    	   \n"
<<"  exportpvd(    namevtu      ,						   \n"
<<"                Th           ,						   \n"
<<"                [du,du1,0]   ,						   \n"
<<"                vtuorder     ,		 		   		   \n"
<<"                withsur      ,		 		   		   \n"
<<"                namedata     ,		 		   		   \n"
<<"                mpiCommWorld			 		   		   \n"
<<"           );				 		   		   \n";

if(plotAll)if(spc==3)writesolver
<<"										   \n"
<<"  //-----------------ParaView plotting--------------//			   \n"
<<"										   \n"
<<"  string   namevtu=\"VTUs/Solution\"+iterout+\"\";			    	   \n"
<<"  exportpvd( namevtu      ,							   \n"
<<"                Th           ,						   \n"
<<"                [du,du1,du2] ,						   \n"
<<"                vtuorder     ,		 		   		   \n"
<<"                withsur      ,		 		   		   \n"
<<"                namedata     ,		 		   		   \n"
<<"                mpiCommWorld			 		   		   \n"
<<"           );				 		   		   \n";

if(pipegnu){writesolver
<<"										   \n"
<<"  //---------------Energy calculations-------------//			   \n"
<<"										   \n"
<<"  E[0] =intN(Th,qforder=3)( 0.5*DPspc*(vold*vold+vold1*vold1));		   \n"
<<"  E[1] =intN(Th,qforder=3)( 0.5*DPspc*(lambda*divergence(uold)*divergence(uold) \n"
<<"                            + 2. * mu * epsilon(uold)'*epsilon(uold))  );	   \n"
<<"  E[2] += dt*intN(Th,qforder=3)( DPspc*(					   \n"
<<"		                  (etam*rho) *def(vold)'*def(vold)		   \n"
<<"		               +  (etak*lambda)*(divergence(vold)*divergence(vold))\n"
<<"		               +  (etak* 2.*mu)*(epsilon(vold)'*epsilon(vold))	   \n"
<<"			          ) );						   \n"
<<"										   \n"
<<"  mpiAllReduce(E[0],EG[0],mpiCommWorld,mpiSUM);				   \n"
<<"  mpiAllReduce(E[1],EG[1],mpiCommWorld,mpiSUM);				   \n"
<<"  mpiAllReduce(E[2],EG[2],mpiCommWorld,mpiSUM);				   \n"
<<"										   \n"
<<"  //----------Appending energies to a file----------//			   \n"
<<"										   \n"
<<"  if(mpirank==0){								   \n"
<<"										   \n"
<<"     ofstream ff(\"energies.data\",append);					   \n"
<<"     ff<< t << \"  \" << EG[0] << \"  \"<< EG[1] << \"  \" << EG[2] <<endl; 	   \n";

if(!supercomp)writesolver
<<"										   \n"
<<"     //---------------Gnuplot pipeping-------------//			   \n"
<<"										   \n"
<<"     pgnuplot <<\"plot\"		 				   	   \n"
<<"     <<\"\\\"energies.data\\\"\" 	   	           			   \n"
<<"     <<\"u ($1):($2) w lp lw 2 pt 7 ps 2 t \\\"K.E\\\",\" 	   		   \n"
<<"     <<\"\\\"energies.data\\\"\" 			   	   	   	   \n"
<<"     <<\"u ($1):($3) w lp lw 2  pt 7 ps 2 t \\\"E.E\\\",\"	   		   \n"
<<"     <<\"\\\"energies.data\\\"\" 	 		  	   		   \n"
<<"     <<\"u ($1):($4) w lp lw 2 pt 7 ps 2 t \\\"D.E\\\",\" 	  		   \n"
<<"     <<\"\\\"energies.data\\\"\" 	   	   	  			   \n"
<<"     <<\"u ($1):($3+$2+$4) w lp lw 2 pt 7 ps 2 t \\\"T.E\\\" \"     		   \n"
<<"     <<\"\\n\"; 	   	   						   \n" 
<<"     flush(pgnuplot);					   	   	   \n";

writesolver
<<"										   \n"
<<"   }							  	   		   \n";
}  //-- [if loop terminator]  pipegnu ended --//



writesolver
<<"										   \n"
<<"  //-----------------updating time----------------//				   \n"
<<"										   \n"
<<"  t += dt; 									   \n";

if(plotAll)writesolver
<<"										   \n"
<<"  //-----------updating iteration count-----------//				   \n"
<<"										   \n"
<<"  iterout++;									   \n";

writesolver
<<"}										   \n"
<<"										   \n";

}  //-- [if loop terminator] Sequential Dynamic ended --//
}  //-- [if loop terminator] !nonlinear ended --//

if(!plotAll)if(!Sequential)writesolver
<<"										   \n"
<<(timelog ? "   MPItimerend(\"Solver\",t1)\n" : ""  	         	  	    )
<<"										   \n";

if(!plotAll)if(Sequential)writesolver
<<"										   \n"
<<(timelog ? "   timerend(\"Solver\",t1)\n" : ""  	         	  	    )
<<"										   \n";


} //-- [ostream terminator]  varfmatsolve.edp closed --//
