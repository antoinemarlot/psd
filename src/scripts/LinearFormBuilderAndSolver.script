//=====================================================================================
// ------ Building the LinearFormBuilderAndSolver.edp file ------ 
//=====================================================================================

{ofstream  writesolver("LinearFormBuilderAndSolver.edp");

writesolver
<<"										   \n"
<<"/**************Variational formulation, solving, & post-proc *******************\n"
<<"*                                                                              *\n"
<<"* Note!!! This file is  generated  by running SolverGenerator.edp. Do not edit *\n"
<<"*         in order to  control this  file please change flag arguments of  the *\n"
<<"*         SolverGenerator, details of which are present in SolverGenerator.edp *\n"
<<"*         or in the README.MD file.                                            *\n"
<<"*                                                                              *\n"
<<"*******************************************************************************/\n"
<<"										   \n"
<<"										   \n";

if(nonlinear){writesolver
<<"										   \n";

if(Sequential)writesolver
<<"										   \n"
<<"//==============================================================================\n"
<<"// ------- L_o calculation -------						   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"{  										   \n"
<<"  fespace  Vh0( Th , P0)    ;						   \n"
<<"  Vh0 size1 = hTriangle     ;						   \n"
<<"  lo = size1[].min          ;						   \n"
<<"  lo = lo*lfac              ;						   \n"
<<"}										   \n"
<<"										   \n"
<<"										   \n"
<<"//==============================================================================\n"
<<"// ------- Defining the matrices and vectors -------				   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"  matrix  A, A1				;  				   \n"
<<"  real[int]  b(Vh.ndof), b1(Vh1.ndof)	;				   \n"
<<"										   \n";

if(pipegnu)if(!supercomp)writesolver
<<"										   \n"
/************************OLD METHOD*************************************************
<<"  matrix  And			;	// PostProcessing		   \n";
if(vectorial)writesolver
<<"  Vh def(fr) 			;	// Variables for force  	   \n"
<<"										   \n"
<<"  int[int]  ldof( 1 )			;				   \n"
<<"  ExtractDofBorderVectorial(2,Vh,ldof)	;				   \n"
<<"										   \n";

if(!vectorial)writesolver
<<"  Vh def2(fr)			;	// Variables for force  	   \n"
<<"										   \n"
<<"  int[int]  ldof( 1 )		;					   \n"
<<"  ExtractDofBorderP1(2,Vh,ldof)	;					   \n"
<<"										   \n";
/************************OLD METHOD*************************************************/  
<<"										   \n"
<<"//==============================================================================\n"
<<"// ------- Gnuplot pipeing -------						   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"  pstream pgnuplot(\"gnuplot -p\")  	;					   \n"
<<"										   \n"
<<"  system(\"rm force.data\")      	;					   \n"
<<"										   \n"
<<"  pgnuplot <<\"set title  \\\"Traction = \"+tr+\"\\\";\\n\";   	 	   \n"
<<"  pgnuplot <<\"set termoption font \\\"Arial-Bold,20\\\";\\n\";  		   \n"
<<"  pgnuplot <<\"set format x \\\"%.1t\\\"		;\\n\";    		   \n"
<<"  pgnuplot <<\"set grid x y 				;\\n\";    		   \n"
<<"  pgnuplot <<\"set xrange [0:.008] 			;\\n\";    		   \n"
<<"  pgnuplot <<\"set yrange [0:.9] 			;\\n\";    		   \n"
<<"  pgnuplot <<\"set xlabel \\\" Displacement \\\"	;\\n\";	   		   \n"
<<"  pgnuplot <<\"set ylabel \\\" Force (kN)\\\"	;\\n\";  	  	   \n"
<<"  pgnuplot <<\"set key left 				;\\n\";    		   \n"
<<"										   \n";

if(!Sequential){writesolver
<<"										   \n"
<<"//==============================================================================\n"
<<"// ------- Partition of unity for integrals -------				   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"  for(int i=0; i<DP.n; i++) 							   \n"
<<"    DPspc[][i]=DP[i];							   \n";

if(!vectorial)writesolver
<<"										   \n"
<<"  for(int i=0; i<DZ.n; i++) 							   \n"
<<"    DZspc[][i]=DZ[i];							   \n";

writesolver
<<"										   \n"
<<"//==============================================================================\n"
<<"// ------- L_o calculation in parallel -------				   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"{ real himlocal,himGlobal                                ;			   \n"
<<"  fespace Vh0(Th,P0)                                     ;			   \n"
<<"  Vh0 size1 = hTriangle                                  ;			   \n"
<<"  himlocal  = size1[].min                                ;			   \n"
<<"  mpiAllReduce(himlocal,himGlobal,mpiCommWorld,mpiMIN)   ;			   \n"
<<"  lo = himGlobal*lfac                                    ;			   \n"
<<"}										   \n";
}


if(Sequential){writesolver
<<"										   \n"
<<"//==============================================================================\n"
<<"// ------- Traction loading loop -------					   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"while (tr <= maxtr){								   \n"
<<"										   \n"
<<"  cout <<  \"-------------------------------------------------------\\n\" 	   \n"
<<"       <<  \"Applied traction \" << tr << \"\\n\" << endl;			   \n"
<<"										   \n"
<<"  if (tr >= 5e-3)								   \n"
<<"    dtr = 1e-6;								   \n"
<<"										   \n"
<<(timelog ? "  timerbegin(\"RHS assembly for U\",t0)\n" : "" 	          	    )
<<"  b = elast(0,Vh);				// Assembly for b (once / NL loop) \n"
<<(timelog ? "  timerend  (\"RHS assembly for U\",t0)\n" : ""  	         	    )
<<"										   \n"
<<"										   \n"
<<"  for(int iter=0; iter<100; iter++){					   	   \n"
<<"										   \n"
<<(timelog ? "    timerbegin(\"matrix assembly for U\",t0)\n" : ""	       	    )
<<"    A = elast(Vh,Vh);				// Assembly for A (for u)   \n"
<<(timelog ? "    timerend  (\"matrix assembly for U\",t0)\n" : ""	            )
<<"										   \n"
<<"										   \n"
<<(timelog ? "    timerbegin(\"Solving U\",t0)\n"         : ""         	  	    )
<<"    set(A,solver=CG);				// Solver setup	   	   \n"
<<"    u[] = A^-1*b;				// Solve u	   		   \n"
<<(timelog ? "    timerend  (\"Solving U\",t0)\n"         : ""         	  	    )
<<"										   \n"
<<"										   \n"
<<(energydecomp ? "    DecomposeElasticEnergy(Hplus,Hminus,H)\n"  : "\n"  	    )
<<"										   \n"
<<"										   \n"
<<(timelog ? "    timerbegin(\"matrix assembly for PHI\",t0)\n" : ""           	    )
<<"    A1 = phase(Vh1,Vh1);			// Assembly for A1 (for phi)  	   \n"
<<(timelog ? "    timerend  (\"matrix assembly for PHI\",t0)\n" : ""           	    )
<<"										   \n"
<<"										   \n"
<<(timelog ? "    timerbegin(\"RHS assembly for PHI\",t0)\n" : "" 	            )
<<"    b1 = phase(0,Vh1);				// Assembly for b (for phi)\n"
<<(timelog ? "    timerend  (\"RHS assembly for U\",t0)\n" : ""  	            )
<<"										   \n"
<<"										   \n"
<<(timelog ? "    timerbegin(\"Solving U\",t0)\n" : "" 	        	  	    )
<<"    set(A1,solver=CG);			// Solver setup	   \n"
<<"    phi[] = A1^-1*b1;				// Solve	   	   \n"
<<(timelog ? "    timerend  (\"Solving U\",t0)\n" : "" 	        	  	    )
<<"										   \n"
<<"										   \n"
<<"    uold[]    = uold[]-u[]                         ;				   \n"
<<"    phiold[]  = phiold[]-phi[]                     ;				   \n"
<<"    real err1 = sqrt( intN(Th,qforder=3) ( uold^2   )  )     ;		   \n"
<<"    real err2 = sqrt( intN(Th,qforder=3) ( phiold^2 )  )     ;		   \n"
<<"										   \n"
<<"      cout.scientific << \"NL iteration number :  [ \"  << iter 	   	   \n"
<<"      << \" ]\\nL2 error in [u,phi] :  [ \"    << err1  			   \n"
<<"      << \" , \" <<  err2 << \" ]\"      << endl;	   			   \n"
<<"										   \n"
<<"    phiold[] = phi[]  ;							   \n"
<<"    uold[]   = u[]    ;							   \n"
<<"										   \n"
<<"    if(err1 < 1e-2 && err2 < 1e-2){						   \n"
<<"										   \n";

if(pipegnu)writesolver
<<"										   \n"
<<"	real forcetot  = 0.;							   \n"
<<"	forcetot = intN1(Th,qforder=3,2)(lambda*divergence(u)+2.*mu*dy(u1));	   \n"
<<"										   \n"       
/************************OLD METHOD*************************************************   
<<"      And = elastNoDirc(Vh,Vh);						   \n"
<<"      fr[] = And*u[];							   \n"
<<"										   \n"
<<"      real forcetot  = 0. ; 							   \n"
<<"      for(int i = 0; i < ldof.n; ++i)					   \n"
<<"        forcetot = forcetot + fr1[][ldof[i]];				   \n"
/************************OLD METHOD*************************************************/
<<"										   \n"
<<"      { ofstream ff(\"force.data\",append);				  	   \n"
<<"        ff << tr << \"	\" << forcetot*1e-3 << endl; 			   \n"
<<"      }									   \n"
<<"										   \n"
<<"										   \n"
<<"      { 							   	   	   \n"
<<"	   pgnuplot <<\"plot					\" 	   	   \n"
<<"		    <<\"    \\\"force.data\\\"			\" 	   	   \n"
<<"		    <<\"	   u 1:2 w lp pt 6 ps 2 t \\\"   FEM\\\",\"  	   \n"
<<"		    <<\"     \\\"ambati.data\\\"		\" 	  	   \n"
<<"		    <<\"	   u 1:2 w lp lt -1 pt 4 ps 2  t \\\"Ref\\\"\"	   \n"
<<"		    <<\"					\\n\"; 	   	   \n" 
<<"        flush(pgnuplot);					   	   	   \n"
<<"       }							  	   	   \n"
<<"									   	   \n"
<<"									   	   \n";

writesolver
<<"										   \n"
<<"      cout.scientific << \" Solution converged after \"       		   \n"
<<"                      <<  iter << endl;					   \n";

if(debug)writesolver
<<"										   \n"	
<<"      plot(phi,fill=1,value=1);				  		   \n";

writesolver
<<"										   \n"	
<<"      break;							   		   \n"
<<"    }									   \n"
<<"  } 										   \n"
<<"	tr += dtr;								   \n"
<<"}										   \n"
<<"										   \n"	
<<"										   \n"
<<"										   \n";

}  //-- [if loop terminator] Sequential ended --//

if(!Sequential){writesolver
<<"										   \n"
<<"//==============================================================================\n"
<<"// ------- Sparsity conservation and defining matrices and vectors -------	   \n"
<<"//==============================================================================\n"
<<"										   \n"
/************************OLD METHOD*************************************************   
<<"  varf DUMMY(uu,vv) = intN(Th,qforder = 1)(uu*vv)                      ;	   \n"
<<"  matrix  MatDUMMY  = DUMMY(Vh, Vh)                                    ;	   \n"
<<"  Mat  A( MatDUMMY, arrayIntersectionP, restrictionIntersectionP, DP)  ; 	   \n"
<<"  MatDUMMY.resize(0,0)                                                 ;	   \n";
/************************OLD METHOD*************************************************/
<<"  Mat  A( Vh.ndof, arrayIntersectionP, restrictionIntersectionP, DP)   ; 	   \n";


if(!vectorial)writesolver
<<"										   \n"
/************************OLD METHOD*************************************************   
<<"  matrix	 MatDUMMY1 = DUMMY(Vh1, Vh1);					   \n"
<<"  Mat A1(MatDUMMY1, arrayIntersectionZ, restrictionIntersectionZ, DZ);  	   \n"
<<"  MatDUMMY1.resize(0,0);							   \n"
/************************OLD METHOD*************************************************/
<<"  Mat A1( Vh1.ndof, arrayIntersectionZ, restrictionIntersectionZ, DZ);  	   \n"
<<"										   \n"
<<"  matrix     ALoc, ALoc1                 ;  // Local matrices for bilinear	   \n"
<<"  real[int]  b(Vh.ndof), b1(Vh1.ndof)    ;  // Local vectors for  linear	   \n";

if(vectorial)writesolver
<<"										   \n"
<<"  matrix     ALoc           ;        // Local vectorial matrix for bilinear	   \n"
<<"  real[int]  b(Vh.ndof)     ;        // Local vectorial real vector for linear  \n";

/************************OLD METHOD*************************************************   
if(pipegnu)writesolver
<<"										   \n"
<<"  matrix	 MatDUMMY2 = DUMMY(Vh, Vh);					   \n"
<<"  Mat A2(MatDUMMY2, arrayIntersectionP, restrictionIntersectionP, DP);  	   \n"
<<"  MatDUMMY2.resize(0,0);							   \n"
<<"										   \n";
/************************OLD METHOD*************************************************/

writesolver
<<"										   \n"
<<"//==============================================================================\n"
<<"// -------  Traction loading loop  -------					   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"while (tr <= maxtr){								   \n"
<<"										   \n"
<<"  if(mpirank==0)								   \n"
<<"  cout.scientific<<\"-----------------------------------------------------\\n\" \n"
<<"  <<  \"Applied traction \" << tr << \"\\n\" << endl;	   		   \n"
<<"										   \n"
<<"  if (tr >= 5e-3)								   \n"
<<"    dtr = 1e-6;								   \n"
<<"										   \n"
<<"  //--------------------Assembly for linear----------------------//		   \n"
<<"										   \n"
<<(timelog ? "  MPItimerbegin(\"RHS assembly for U\",t0)\n" : ""       	            )
<<"  b = elast(0,Vh);							 	   \n"
<<(timelog ? "  MPItimerend  (\"RHS assembly for U\",t0)\n" : ""       	  	    )
<<"										   \n"
<<"  //-----------------------Nonlinear loop------------------------//		   \n"
<<"										   \n"
<<"  for(int iter=0; iter<100; iter++){					   	   \n"
<<"										   \n"
<<"    //----------------Assembly for bilinear----------------------//	 	   \n"
<<"										   \n"
<<(timelog ? "    MPItimerbegin(\"matrix assembly for U\",t0)\n" : ""         	    )
<<"    ALoc = elast(Vh,Vh);						  	   \n"
<<(timelog ? "    MPItimerend  (\"matrix assembly for U\",t0)\n" : ""          	    )
<<"										   \n"
<<"    //-----------PETSc assembly for bilinear---------------------//		   \n"
<<"										   \n"
<<(timelog ? "    MPItimerbegin(\"PETSc assembly for U\",t0)\n" : ""           	    )
<<"    changeOperator(A, ALoc);				   	   		   \n"
<<"    set(A,sparams =\" \");						   	   \n"
<<(timelog ? "    MPItimerend  (\"PETSc assembly for U\",t0)\n" : ""   	  	    )
<<"										   \n"
<<"    //-------------Linear system solving phase-------------------//		   \n"
<<"										   \n"
<<(timelog ? "    MPItimerbegin(\"solving U\",t0)\n" : " "         	  	    )
<<"    u[] = A^-1*b;	                         // Solve u			   \n"
<<(timelog ? "    MPItimerend  (\"solving U\",t0)\n" : " "           	  	    )
<<"										   \n";

if(!vectorial)writesolver
<<"										   \n"
<<"    //---------------Energy decomposition phase-------------------//	   	   \n"
<<"										   \n"
<<(energydecomp ? "    DecomposeElasticEnergy(Hplus,Hminus,H)\n"  : "\n"  	    )
<<"										   \n"
<<"    //----------------Assembly for bilinear----------------------//	 	   \n"
<<"										   \n"
<<(timelog ? "    MPItimerbegin(\"matrix assembly for PHI\",t0)\n" : ""        	    )
<<"    ALoc1 = phase(Vh1,Vh1);		// Assembly bilinear	   		   \n"
<<(timelog ? "    MPItimerend  (\"matrix assembly PHI\",t0)\n" : ""    	  	    )
<<"										   \n"
<<"    //----------------Assembly for linear------------------------//	 	   \n"
<<"										   \n"
<<(timelog ? "    MPItimerbegin(\"RHS assembly for PHI\",t0)\n" : ""           	    )
<<"    b1 = phase(0,Vh1);	// Assembly linear	   			   \n"
<<(timelog ? "    MPItimerend  (\"RHS assembly for PHI\",t0)\n" : ""           	    )
<<"										   \n"
<<"    //-----------PETSc assembly for bilinear---------------------//		   \n"
<<"										   \n"
<<(timelog ? "    MPItimerbegin(\"PETSc assembly for PHI\",t0)\n" : ""         	    )
<<"    changeOperator(A1, ALoc1);					  	   \n"
<<"    set(A1,sparams =\" \");		// Solver setup		   		   \n"
<<(timelog ? "    MPItimerend  (\"PETSc assembly for PHI\",t0)\n" : ""         	    )
<<"										   \n"
<<"    //-------------Linear system solving phase-------------------//		   \n"
<<"										   \n"
<<(timelog ? "    MPItimerbegin(\"solving PHI\",t0)\n" : ""    		       	    )
<<"    phi[] = A1^-1*b1;		// Solve phi	  	   		   \n"
<<(timelog ? "    MPItimerend  (\"solving PHI\",t0)\n" : ""           	  	    )
<<"										   \n"
<<"    //------------------Error calculation------------------------//		   \n"
<<"										   \n"
<<"    uold[]   = uold[]-u[]		;					   \n"
<<"    phiold[] = phiold[]-phi[]	; 					   \n"
<<"										   \n"
<<"    real err1Gather,err2Gather;						   \n"
<<"    real err1Loc=sqrt( intN(Th,qforder=3) ( DPspc*(uold)^2   )  );		   \n"
<<"    real err2Loc=sqrt( intN(Th,qforder=3) ( DZspc*(phiold)^2 )  );		   \n"
<<"										   \n"
<<"    mpiAllReduce(err1Loc,err1Gather,mpiCommWorld,mpiSUM);			   \n"
<<"    mpiAllReduce(err2Loc,err2Gather,mpiCommWorld,mpiSUM);			   \n"
<<"										   \n"
<<"    if(mpirank==0)							      	   \n"
<<"    cout.scientific << \"NL iteration number :  [ \"  << iter 	   	   \n"
<<"    << \" ]\\nL2 error in [u,phi] :  [ \"    << err1Gather  		 	   \n"
<<"    << \" , \" <<  err2Gather << \" ]\"      << endl;	   		   \n"
<<"										   \n"
<<"    //--------------------Solution update-------------------------//		   \n"
<<"										   \n"
<<"    phiold[]=phi[];							   	   \n"
<<"    uold[]=u[];							   	   \n"
<<"										   \n"
<<"    if(err1Gather < 1e-2 && err2Gather < 1e-2){			   	   \n";


if(vectorial){writesolver
<<"										   \n"
<<"    //------------------Error calculation------------------------//		   \n"
<<"										   \n"
<<"    uold[]   = uold[]-u[]    ;						   \n";

writesolver
<<"										   \n"
<<"    real err1Gather                                                ;		   \n"
<<"    real err1Loc=sqrt( intN(Th,qforder=3) ( DPspc*(uold)^2 )  )    ;		   \n"
<<"    mpiAllReduce(err1Loc,err1Gather,mpiCommWorld,mpiSUM)           ;		   \n"
<<"										   \n"
<<"    if(mpirank==0)							      	   \n"
<<"    cout.scientific << \"NL iteration number :  [ \" << iter    		   \n"
<<"    << \" ]\\nL2  error  in  [U]  :  [ \" << err1Gather << \" ]\" <<endl;	   \n"
<<"										   \n"
<<"    //--------------------Solution update-------------------------//		   \n"
<<"										   \n"
<<"    uold[] = u[];							   	   \n"
<<"										   \n"
<<"    //---------------Energy decomposition phase-------------------//	  	   \n"
<<"										   \n"
<<(energydecomp ? "    DecomposeElasticEnergy(Hplus,Hminus,H)\n"  : "\n"  	    )
<<"										   \n"
<<"    //--------------- Convergence conditional---------------------//	  	   \n"
<<"										   \n"
<<"    if(err1Gather < 1e-2){						   	   \n";

}  //-- [if loop terminator] vectorial ended --//

if(pipegnu){writesolver
<<"										   \n"
<<"	real forcetot  = 0., forcetotGath  = 0. ;				   \n"
<<"	forcetot=intN1(Th,qforder=3,2)(DPspc*(lambda*divergence(u)+2.*mu*dy(u1))); \n"
<<"										   \n"
/************************OLD METHOD*************************************************
<<"	And = elastNoDirc(Vh,Vh);						   \n"
<<"	changeOperator(A2, And);						   \n"
<<"	fr[] = And*u[];								   \n"
<<"										   \n"
<<"	fr[] .*= DP;								   \n"
<<"										   \n"
<<"	real forcetot  = 0.,forcetotGath  = 0. ;				   \n"
<<"		for(int i = 0; i < ldof.n; ++i)					   \n"
<<"		forcetot = forcetot + fr1[][ldof[i]];				   \n"
<<"										   \n"
/************************OLD METHOD*************************************************/
<<"										   \n"
<<"	mpiAllReduce(forcetot,forcetotGath,mpiCommWorld,mpiSUM);		   \n"
<<"										   \n"
<<"	if(mpirank==0){								   \n"
<<"	{ ofstream ff(\"force.data\",append);					   \n"
<<"		ff << tr << \"	\" << forcetotGath*1e-3 << endl;		   \n"
<<"	}									   \n"
<<"										   \n";

if(!supercomp)writesolver
<<"										   \n"
<<"      { 							   	   	   \n"
<<"	   pgnuplot <<\"plot					\" 	   	   \n"
<<"		    <<\"    \\\"force.data\\\"			\" 	   	   \n"
<<"		    <<\"	   u ($1):($2) w lp pt 6 ps 2 t \\\"   FEM\\\",\"  \n"
<<"		    <<\"     \\\"ambati.data\\\"		\" 	  	   \n"
<<"		    <<\"	   u ($1):($2) w lp lt 5 pt 4 ps 2  t \\\"Ref\\\"\"\n"
<<"		    <<\"					\\n\"; 	   	   \n" 
<<"        flush(pgnuplot);					   	   	   \n"
<<"       }							  	   	   \n";

writesolver
<<"										   \n"
<<"	  }								   	   \n"
<<"									   	   \n";
}  //-- [if loop terminator] !pipegnu ended --//

if(plotAll)if(!vectorial)writesolver
<<"										   \n"
<<"      iterout++;								   \n"
<<"										   \n"
<<"      if(int(iterout%10)==0){						   \n"
<<"										   \n"
<<"        //-----------------Paraview plotting----------------------//  	   \n"
<<"										   \n"
<<(timelog ? "        MPItimerbegin(\"post-processing\",t0)\n" : ""           	    )
<<"										   \n"
<<"        int[int] vtuorder=[1,1,1,1];						   \n" 
<<"        string   namevtu=\"VTUs/Solution\"+iterout1+\"\";			   \n"
<<"        string   namedata=\"U Phi\";						   \n"
<<"        bool     withsur=true;						   \n"
<<"										   \n"
<<"        exportpvd2(  namevtu            , 					   \n"
<<"                     Th                 ,				   	   \n"
<<(spc==2 ? "\t\t     [u,u1,0]\t\t,\n" : "\t\t     [u,u1,u2]\t\t,\n" 	   	    )
<<"                     phi                ,				   	   \n"
<<"                     vtuorder           ,				   	   \n"
<<"                     withsur            ,				   	   \n"
<<"                     namedata           ,				   	   \n"
<<"                     mpiCommWorld       				   	   \n"
<<"                  );			       				   	   \n"
<<"										   \n"
<<(timelog ? "        MPItimerend  (\"post-processing\",t0)\n" : ""    	    	    )
<<"        iterout1++;								   \n"
<<"	}									   \n"
<<"										   \n";

if(plotAll)if(vectorial)writesolver
<<"										   \n"
<<"      iterout++;								   \n"
<<"										   \n"
<<"      if(int(iterout%10)==0){						   \n"
<<"										   \n"
<<"        //-----------------Paraview plotting----------------------//  	   \n"
<<"										   \n"
<<(timelog ? "        MPItimerbegin(\"post-processing\",t0)\n" : ""           	    )
<<"										   \n"
<<"        int[int] vtuorder=[1,1,1,1];						   \n" 
<<"        string   namevtu=\"VTUs/Solution\"+iterout1+\"\";			   \n"
<<"        string   namedata=\"U Phi\";						   \n"
<<"        bool     withsur=true;						   \n"
<<"										   \n"
<<"        exportpvd2(  namevtu            , 					   \n"
<<"                     Th                 ,				   	   \n"
<<(spc==2 ? "\t\t     [u,u1,0]\t\t,\n" : "\t\t     [u,u1,u2]\t\t,\n" 	   	    )
<<"                     phi                ,				   	   \n"
<<"                     vtuorder           ,				   	   \n"
<<"                     withsur            ,				   	   \n"
<<"                     namedata           ,				   	   \n"
<<"                     mpiCommWorld       				   	   \n"
<<"                  );			       				   	   \n"
<<"										   \n"
<<(timelog ? "        MPItimerend  (\"post-processing\",t0)\n" : ""    	    	    )
<<"										   \n"
<<"        iterout1++;								   \n"
<<"      }									   \n";


if(plotAll || debug)if(vectorial)writesolver
<<"										   \n"
<<"      //-----------------Debug glut plotting----------------------//  	   \n"
<<"										   \n"
<<"      phi = u"+spc+";							   \n";

if(debug)if(!vectorial)writesolver
<<"										   \n"
<<"      //-----------------Debug glut plotting----------------------//  	   \n"
<<"										   \n"
<<"      plotMPI(Th, phi[],\"Tr-\"+tr+\"\", Zk, def, real, 2, 0)		   \n";

if(debug)if(vectorial)writesolver
<<"      plotMPI(Th, phi[],\"Tr-\"+tr+\"\", Pltk, def0, real, 2, 0)		   \n";

writesolver
<<"										   \n"
<<"      break;									   \n"
<<"    }									   \n"
<<"  } 									  	   \n"
<<"  tr += dtr;									   \n"
<<"}										   \n"
<<"										   \n"	
<<"										   \n";

}  //-- [if loop terminator] !Sequential ended --//
 
}  //-- [if loop terminator] nonlinear ended --//

if(!nonlinear){

if(!Sequential)if(!dynamic){writesolver      
<<"										   \n"	
<<"//==============================================================================\n"
<<"//  ------- Local Au=b assembly and solving -------				   \n"
<<"//==============================================================================\n"	
<<"										   \n"
<<"//-----------------Assembly for A-----------------//				   \n"
<<"										   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"matrix Assembly\",t0)\n" : " "           	    )
<<"  matrix	ALoc = elast(Vh,Vh);		// Assembly bilinear		   \n"
<<(timelog ? "	MPItimerend  (\"matrix Assembly\",t0)\n" : " "       	    	    )
<<"										   \n"
<<"										   \n"
<<"//-----------------Assembly for b-----------------//				   \n"
<<"										   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"RHS assembly\",t0)\n" : " "          	 	    )
<<"	real[int]    b = elast(0,Vh);			// Assembly linear	   \n"
<<(timelog ? "	MPItimerend  (\"RHS assembly\",t0)\n" : " "       	    	    )
<<"										   \n";

if(pointbc)writesolver
<<"										   \n"
<<"//---------Additional assembly for A & b----------//				   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"point Dirichlet assembly\",t0)\n" : " "  	    )
<<"  Pointbc(Dpointlab,Vh,ALoc,b,PnV);			// Assembly linear	   \n"
<<(timelog ? "	MPItimerend(\"point Dirichlet assembly\",t0)\n" : " "        	    )
<<"										   \n";

writesolver
<<"										   \n"
<<" //------------Memory optimization-----------------//			   \n"
<<"										   \n";

if(pointbc)writesolver
<<"										   \n"
<<"  Dpointlab.resize(0); PnV.resize(0);					   \n"
<<"										   \n";

if(dirichletbc)writesolver
<<"										   \n"
<<"  Dlabel.resize(0); Dvalue.resize(0);					   \n"
<<"										   \n";

if(tractionbc)writesolver
<<"										   \n"
<<"  Tlabel.resize(0);								   \n"
<<"										   \n"; 
   
writesolver
<<"										   \n"
<<"//---------------PETSc Assembly---------------------//			   \n"
<<"										   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"PETSc assembly\",t0)\n" : " "  	    		   )
<<"      Mat A				// Distributed matrix 		   	   \n"
<<"		  ( ALoc			, 				   \n"
<<"		    arrayIntersectionP		,				   \n"
<<"                 restrictionIntersectionP	,				   \n"
<<" 		    DP				,				   \n"
<<" 		    bs = "+spc+" 						   \n"
<<"		  );								   \n"
<<(timelog ? "	MPItimerend(\"PETSc assembly\",t0)\n" : " "  	    		   )
<<"										   \n"
<<"										   \n"
<<"//------------PETSc solving------------------//				   \n"
<<"										   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"PETSc solving\",t0)\n" : " "  	    		   )
<<"      Vh<real> def(u);							   \n"
<<"      set(A,sparams =\" \");            // Solver setup-Petsc		   \n"
<<"      u[] = A^-1*b;                     // Solving				   \n"
<<"										   \n"
<<(timelog ? "	MPItimerend(\"PETSc solving\",t0)\n" : " "  	    		   )
<<"										   \n"       
<<"										   \n";

}  //-- [if loop terminator] !Sequential ended --//

if(Sequential)if(!dynamic){writesolver    
<<"										   \n"	
<<"//==============================================================================\n"
<<"//  -------Local Au=b assembly and solving-------				   \n"
<<"//==============================================================================\n"	
<<"										   \n"
<<"  Vh  def(u)   ;	// Defining vectorial FE variables 			   \n"
<<"										   \n"
<<"  //-----------------Assembly for A-----------------//			   \n"
<<"										   \n"
<<(timelog ? "	timerbegin(\"matrix assembly\",t0)\n" : " "  	    		   )
<<"		matrix<real> A = elast(Vh,Vh);		// Assembly for A	   \n"
<<(timelog ? "	timerend  (\"matrix assembly\",t0)\n" : " "  	    		   )
<<"										   \n"
<<"  //-----------------Assembly for b-----------------//			   \n"
<<"										   \n"
<<(timelog ? "	timerbegin(\"RHS assembly\",t0)\n" : " "  	    		   )
<<"		real[int]    b = elast(0,Vh);		// Assembly for b	   \n"
<<(timelog ? "	timerend  (\"RHS assembly\",t0)\n" : " "  	    		   )
<<"										   \n"
<<"  //-----------------Solving du=A^-1*b--------------//			   \n"
<<"										   \n"
<<(timelog ? "	timerbegin(\"solving U\",t0)\n" : " "  	    		   	   )
<<"		set(A,solver=CG);			// Solver setup		   \n"
<<"		u[] = A^-1*b;				// Solving		   \n"
<<(timelog ? "	timerend  (\"solving U\",t0)\n" : " "  	   	 		   )
<<"										   \n";

if(debug)writesolver
<<"										   \n"
<<"  //-----------------debug  plotting---------------//			   \n"
<<"										   \n"
<<"  plot (u,wait=0, cmm= \"solution\")  ;				   \n"
<<"										   \n";


}  //-- [if loop terminator] Sequential Not Dynamic ended --//


if(Sequential)if(dynamic){writesolver    
<<"										   \n";


if(pipegnu)if(!supercomp)writesolver
<<"										   \n"
<<"//==============================================================================\n"
<<"// ------- Gnuplot pipeing -------						   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"  pstream pgnuplot(\"gnuplot -p\")  	;					   \n"
<<"										   \n"
<<"  system(\"rm energies.data\")      	;					   \n"
<<"										   \n"
<<"  real Ec				;  // To store damping energy		   \n"
<<"										   \n"
<<"  pgnuplot <<\"set title\\\"E-Energy\t E-Elastic\tT-Total\tK-Kinetic\\\";\\n\"; \n"
<<"  pgnuplot <<\"set termoption font \\\"Arial-Bold,20\\\";\\n\";  		   \n"
<<"  pgnuplot <<\"set format x \\\"%.1t\\\"		;\\n\";    		   \n"
<<"  pgnuplot <<\"set grid x y 				;\\n\";    		   \n"
<<"  pgnuplot <<\"set xlabel \\\" Time     \\\"	;\\n\";	   		   	   \n"
<<"  pgnuplot <<\"set ylabel \\\" Energies \\\"	;\\n\";  	  	   	   \n"
<<"  pgnuplot <<\"set key left 				;\\n\";    		   \n"
<<"										   \n";


if(plotAll)writesolver
<<"										   \n"
<<"//==============================================================================\n"
<<"//  ------- Paraview plotting support -------				   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"  int[int] vtuorder = [1,1,1];                       // Solution export order   \n"
<<"  string   namedata = \"U\";			     // Name of export data	   \n"
<<"  bool     withsur  = true;							   \n"
<<"										   \n";

writesolver
<<"										   \n"
<<"//==============================================================================\n"
<<"//  ------- Dynamic loop for linear assembly and solving -------		   \n"
<<"//==============================================================================\n"	
<<"										   \n"
<<"  int j=0;									   \n"
<<"										   \n"
<<"while (t <= tmax){								   \n"
<<"										   \n"
<<"  cout.scientific << \"Time iteration at t :\" << t << \" (s) \"<< endl;	   \n"
<<"										   \n"
<<"  tt  = t-real(alpf*dt);                            // tt update for loading    \n"
<<"										   \n"
<<"  //-----------------Assembly for A-----------------//			   \n"
<<"										   \n"
<<(timelog ? "	timerbegin(\"matrix assembly\",t0)\n" : " "  	    		   )
<<"  matrix<real> A = elastodynamics(Vh,Vh,tgv=-1);   // Assembly for A            \n"
<<(timelog ? "	timerend  (\"matrix assembly\",t0)\n" : " "  	    		   )
<<"										   \n"
<<"  //-----------------Assembly for b-----------------//			   \n"
<<"										   \n"
<<(timelog ? "	timerbegin(\"RHS assembly\",t0)\n" : " "  	    		   )
<<"  real[int]    b = elastodynamics(0,Vh,tgv=-1);    // Assembly for b	           \n"
<<(timelog ? "	timerend  (\"RHS assembly\",t0)\n" : " "  	    		   )
<<"										   \n"
<<"  //-----------------Solving du=A^-1*b--------------//			   \n"
<<"										   \n"
<<(timelog ? "	timerbegin(\"solving U\",t0)\n" : " "  	    		   	   )
<<"  set(A,solver=UMFPACK);                           // Solver setup		   \n"
<<"   du[] = A^-1*b;                                   // Solving		   \n"
<<(timelog ? "	timerend  (\"solving U\",t0)\n" : " "  	   	 		   )
<<"										   \n";

if(debug)if(spc==2)writesolver
<<"										   \n"
<<"  //-----------------Move mesh plotting------------//			   \n"
<<"										   \n"
<<"  meshN ThMoved = movemesh(Th, [x + du, y + du1]) ; 				   \n"
<<"  plot (ThMoved,wait=0, cmm= \"t = \"+t+\" (s)\")  ;				   \n"
<<"										   \n";

if(debug)if(spc==3)writesolver
<<"										   \n"
<<"  //-----------------Move mesh plotting------------//			   \n"
<<"										   \n"
<<"  meshN ThMoved = movemesh3(Th, transfo =[x + du, y + du1, z + du2]) ; 	   \n"
<<"  plot (ThMoved,wait=0, cmm= \"t = \"+t+\" (s)\")  ;				   \n"
<<"										   \n";

writesolver
<<"										   \n"
<<"  //-----------------updating variables------------//			   \n"
<<"										   \n"
<<"  GFPUpdateDynamic(du[],uold[],vold[],aold[],beta,gamma,dt);			   \n"
//<<"  updateVariables(du,uold,vold,aold)					   \n"
<<"  										   \n";

if(plotAll)writesolver
<<"										   \n"
<<"  //-----------------Paraview plotting-------------//			   \n"
<<"										   \n"
<<"  string   namevtu=\"VTUs/Solution\"+j+\".vtu\";        // Name of PV files     \n"
<<"  savevtk(namevtu, Th,[uold,uold1,0], order=vtuorder, dataname=namedata );	   \n"
<<"										   \n";



if(pipegnu){writesolver
<<"										   \n"
<<"  //-----------------Gnuplot plotting--------------//			   \n"
<<"										   \n"
<<"										   \n"
<<"  real Ek =intN(Th,qforder=3)(0.5*(vold*vold+vold1*vold1));			   \n"
<<"  real El =intN(Th,qforder=3)(0.5*(lambda*divergence(uold)*divergence(uold) 	   \n"
<<"                         + 2. * mu * epsilon(uold)'*epsilon(uold)) );	   \n"
<<"       Ec += dt*intN(Th,qforder=3)(						   \n"
<<"	                      (etam*rho) *def(vold)'*def(vold)			   \n"
<<"                         + (etak*lambda)*(divergence(vold)*divergence(vold))	   \n"
<<"			    + (etak* 2.*mu)*(epsilon(vold)'*epsilon(vold)) );	   \n"
<<"										   \n"
<<"   ofstream ff(\"energies.data\",append);{					   \n"
<<"        ff<< t << \"  \" << Ek << \"  \"<< El << \"  \" << Ec <<endl;	   \n"
<<"   }										   \n"
<<"										   \n";

if(!supercomp)writesolver
<<"										   \n"
<<"										   \n"
<<"      { 							   	   	   \n"
<<"	   pgnuplot <<\"plot					\" 	   	   \n"
<<"		    <<\"\\\"energies.data\\\"		\" 	   	           \n"
<<"		    <<\"u ($1):($2) w lp lw 2 pt 7 ps 2 t \\\"K.E\\\",\" 	   \n"
<<"		    <<\"\\\"energies.data\\\"		\" 	   	   	   \n"
<<"		    <<\"u ($1):($3) w lp lw 2  pt 7 ps 2 t \\\"E.E\\\",\"	   \n"
<<"		    <<\"\\\"energies.data\\\"		\" 	   	   	   \n"
<<"		    <<\"u ($1):($4) w lp lw 2 pt 7 ps 2 t \\\"D.E\\\",\" 	   \n"
<<"		    <<\"\\\"energies.data\\\"		\" 	   	   	   \n"
<<"		    <<\"u ($1):($3+$2+$4) w lp lw 2 pt 7 ps 2 t \\\"T.E\\\" \"     \n"
<<"		    <<\"					\\n\"; 	   	   \n" 
<<"        flush(pgnuplot);					   	   	   \n"
<<"       }							  	   	   \n";
}  //-- [if loop terminator]  pipegnu ended --//



writesolver
<<"										   \n"
<<"  //-----------------updating time----------------//				   \n"
<<"										   \n"
<<"  t += dt; j++;								   \n"
<<"}										   \n"
<<"										   \n";

}  //-- [if loop terminator] Sequential Dynamic ended --//


if(!Sequential)if(dynamic){writesolver    
<<"										   \n";


if(pipegnu)if(!supercomp)writesolver
<<"										   \n"
<<"//==============================================================================\n"
<<"// ------- Gnuplot pipeing -------						   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"  pstream pgnuplot(\"gnuplot -p\")  	;					   \n"
<<"										   \n"
<<"  system(\"rm energies.data\")      	;					   \n"
<<"										   \n"
<<"  real[int] E(3),EG(3)		;  // To store Energies E1-Ke E2-El E3-D   \n"
<<"										   \n"
<<"  pgnuplot <<\"set title\\\"E-Energy\t E-Elastic\tT-Total\tK-Kinetic\\\";\\n\"; \n"
<<"  pgnuplot <<\"set termoption font \\\"Arial-Bold,20\\\";\\n\";  		   \n"
<<"  pgnuplot <<\"set format x \\\"%.1t\\\"		;\\n\";    		   \n"
<<"  pgnuplot <<\"set grid x y 				;\\n\";    		   \n"
<<"  pgnuplot <<\"set xlabel \\\" Time     \\\"	;\\n\";	   		   	   \n"
<<"  pgnuplot <<\"set ylabel \\\" Energies \\\"	;\\n\";  	  	   	   \n"
<<"  pgnuplot <<\"set key left 				;\\n\";    		   \n"
<<"										   \n";


if(pipegnu)writesolver
<<"										   \n"
<<"//==============================================================================\n"
<<"// ------- Partion of unity for integrals -------				   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"  for(int i=0; i<DP.n; i++) 							   \n"
<<"    DPspc[][i]=DP[i];							   \n"
<<"										   \n"
<<"										   \n";


if(plotAll)writesolver
<<"										   \n"
<<"//==============================================================================\n"
<<"//  -------Paraview plotting support-------					   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<"  int[int] vtuorder = [1,1,1];                       // Solution export order   \n"
<<"  bool     withsur  = true;							   \n"
<<"  string   namedata=\"U\";			// Name of export data	   	   \n"
<<"										   \n";

writesolver
<<"										   \n"
<<"//==============================================================================\n"
<<"//  -------Defining the FE linear system matrix and vector-------		   \n"
<<"//==============================================================================\n"
<<"										   \n"
<<" matrix       ALoc    ;							   \n"
<<" real[int]    b(Vh.ndof);							   \n"
<<"										   \n"
<<"										   \n"
/************************OLD METHOD*************************************************   
<<"  varf DUMMY(uu,vv) = intN(Th,qforder = 1)(uu*vv)                      ;	   \n"
<<"  matrix  MatDUMMY  = DUMMY(Vh, Vh)                                    ;	   \n"
<<"  Mat  A( MatDUMMY, arrayIntersectionP, restrictionIntersectionP, DP)  ; 	   \n"
<<"  MatDUMMY.resize(0,0)                                                 ;	   \n"
/**********************************************************************************/
<<"  Mat  A(Vh.ndof, arrayIntersectionP, restrictionIntersectionP, DP)  ; 	   \n"
<<"										   \n"
<<"										   \n"
<<"										   \n"
<<"//==============================================================================\n"
<<"//  -------Dynamic loop for linear assembly and solving-------		   \n"
<<"//==============================================================================\n"	
<<"										   \n"
<<"  int j=0;									   \n"
<<"										   \n"
<<"while (t <= tmax){								   \n"
<<"										   \n"
<<"  if(mpirank==0)								   \n"
<<"    cout.scientific << \"Time iteration at t :\" << t << \" (s) \"<< endl;	   \n"
<<"										   \n"
<<"  tt  = t-real(alpf*dt);                            // tt update for loading    \n"
<<"										   \n"
<<"  //-----------------Assembly for A-----------------//			   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"matrix assembly\",t0)\n" : " "  	    	   )
<<"  ALoc = elastodynamics(Vh,Vh,tgv=-1);   // Assembly for A          	           \n"
<<(timelog ? "	MPItimerend  (\"matrix assembly\",t0)\n" : " "  	    	   )
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"PETSc assembly\",t0)\n" : " "  	    		   )
<<"  changeOperator(A, ALoc);			 				   \n"
<<(timelog ? "	MPItimerend(\"PETSc assembly\",t0)\n" : " "  	    		   )
<<"										   \n"
<<"  //-----------------Assembly for b-----------------//			   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"RHS assembly\",t0)\n" : " "  	    		   )
<<"  b = elastodynamics(0,Vh,tgv=-1);    // Assembly for b	           	   \n"
<<(timelog ? "	MPItimerend  (\"RHS assembly\",t0)\n" : " "  	    		   )
<<"										   \n"
<<"  //-----------------Solving du=A^-1*b--------------//			   \n"
<<"										   \n"
<<(timelog ? "	MPItimerbegin(\"solving U\",t0)\n" : " "  	    	   	   )
<<"  set(A,sparams =\" \");                           // Solver setup		   \n"
<<"   du[] = A^-1*b;                                   // Solving		   \n"
<<(timelog ? "	MPItimerend  (\"solving U\",t0)\n" : " "  	   		   )
<<"										   \n";

if(debug)if(spc==2)writesolver
<<"										   \n"
<<"  //-----------------Move mesh plotting------------//			   \n"
<<"										   \n"
<<"  meshN ThMoved = movemesh(Th, [x + du, y + du1]) ; 				   \n"
<<"  plotMPI (ThMoved,du[],\"t = \"+t+\" (s)\",Pk, def, real, 2, 0)  ;		   \n"
<<"										   \n";

if(debug)if(spc==3)writesolver
<<"										   \n"
<<"  //-----------------Move mesh plotting------------//			   \n"
<<"										   \n"
<<"  meshN ThMoved = movemesh3(Th, transfo =[x + du, y + du1, z + du2]) ; 	   \n"
<<"  plotMPI (ThMoved,du[],\"t = \"+t+\" (s)\",Pk, def, real, 3, 0)  ;		   \n"
<<"										   \n";

writesolver
<<"										   \n"
<<"  //-----------------updating variables------------//			   \n"
<<"										   \n"
<<"  GFPUpdateDynamic(du[],uold[],vold[],aold[],beta,gamma,dt);			   \n"
//<<"  updateVariables(du,uold,vold,aold)					   \n"
<<"  										   \n";


if(plotAll)writesolver
<<"										   \n"
<<"										   \n"
<<"	string   namevtu=\"VTUs/Solution\"+j+\"\";// Name of PV files	    	   \n"
<<"	exportpvd(namevtu, Th,			 		   		   \n"
<<(spc==2 ? "      \t[du,du1,0],\n" : "      \t[du,du1,du2],\n" 	    	    )
<<"     vtuorder, withsur, namedata, mpiCommWorld);				   \n" 
<<"										   \n";




if(pipegnu){writesolver
<<"										   \n"
<<"  //-----------------Gnuplot plotting--------------//			   \n"
<<"										   \n"
<<"										   \n"
<<"  E[0] =intN(Th,qforder=3)( 0.5*DPspc*(vold*vold+vold1*vold1));		   \n"
<<"  E[1] =intN(Th,qforder=3)( 0.5*DPspc*(lambda*divergence(uold)*divergence(uold) \n"
<<"                            + 2. * mu * epsilon(uold)'*epsilon(uold))  );	   \n"
<<"  E[2] += dt*intN(Th,qforder=3)( DPspc*(					   \n"
<<"		                  (etam*rho) *def(vold)'*def(vold)		   \n"
<<"		               +  (etak*lambda)*(divergence(vold)*divergence(vold))\n"
<<"		               +  (etak* 2.*mu)*(epsilon(vold)'*epsilon(vold))	   \n"
<<"			          ) );						   \n"
<<"										   \n"
<<"    mpiAllReduce(E[0],EG[0],mpiCommWorld,mpiSUM);				   \n"
<<"    mpiAllReduce(E[1],EG[1],mpiCommWorld,mpiSUM);				   \n"
<<"    mpiAllReduce(E[2],EG[2],mpiCommWorld,mpiSUM);				   \n"
<<"										   \n"
<<"										   \n"
<<"   if(mpirank==0)								   \n"
<<"   {ofstream ff(\"energies.data\",append);					   \n"
<<"        ff<< t << \"  \" << EG[0] << \"  \"<< EG[1] << \"  \" << EG[2] <<endl;  \n"
<<"   }										   \n"
<<"										   \n";

if(!supercomp)writesolver
<<"										   \n"
<<"	 if(mpirank==0)								   \n"
<<"      { 							   	   	   \n"
<<"	   pgnuplot <<\"plot					\" 	   	   \n"
<<"		    <<\"\\\"energies.data\\\"		\" 	   	           \n"
<<"		    <<\"u ($1):($2) w lp lw 2 pt 7 ps 2 t \\\"K.E\\\",\" 	   \n"
<<"		    <<\"\\\"energies.data\\\"		\" 	   	   	   \n"
<<"		    <<\"u ($1):($3) w lp lw 2  pt 7 ps 2 t \\\"E.E\\\",\"	   \n"
<<"		    <<\"\\\"energies.data\\\"		\" 	   	   	   \n"
<<"		    <<\"u ($1):($4) w lp lw 2 pt 7 ps 2 t \\\"D.E\\\",\" 	   \n"
<<"		    <<\"\\\"energies.data\\\"		\" 	   	   	   \n"
<<"		    <<\"u ($1):($3+$2+$4) w lp lw 2 pt 7 ps 2 t \\\"T.E\\\" \"     \n"
<<"		    <<\"					\\n\"; 	   	   \n" 
<<"        flush(pgnuplot);					   	   	   \n"
<<"       }							  	   	   \n";
}  //-- [if loop terminator]  pipegnu ended --//



writesolver
<<"										   \n"
<<"  //-----------------updating time----------------//				   \n"
<<"										   \n"
<<"  t += dt; j++;								   \n"
<<"}										   \n"
<<"										   \n";

}  //-- [if loop terminator] Sequential Dynamic ended --//
}  //-- [if loop terminator] !nonlinear ended --//

if(!plotAll)if(!Sequential)writesolver
<<"										   \n"
<<(timelog ? "   MPItimerend(\"Solver\",t1)\n" : ""  	         	  	    )
<<"										   \n";

if(!plotAll)if(Sequential)writesolver
<<"										   \n"
<<(timelog ? "   timerend(\"Solver\",t1)\n" : ""  	         	  	    )
<<"										   \n";


} //-- [ostream terminator]  varfmatsolve.edp closed --//
