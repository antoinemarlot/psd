//=======================================================================================
//@DSL DefaultDSL;
@DSL DefaultGenericBehaviour;
@Behaviour Hujeux;
@Date 10-05-2022;
@Description{

 Hujeux behaviour model is a cyclic constitutive law for non-linear soil behaviour.
 the model comprises a nonlinear elasticity controlled by  the  Young  modulus that
 depends on the confining pressure.

 Reference:
 J. C. Hujeux, A constitutive law for the cyclic loading of the soils.
 Parasismique genius Presses ENPC, Davidovici V. & al., pages 287-302, 1985

 D. Aubry , J.C. Hujeux, F. Lassoudiere & Y. Meimon, A doubles memory
 multiple model with mechanisms for cyclic soil behaviors,
 Int. Symp. Num. Models in Geomechanics, Zurich, vol. 1, pp 3-13, (1982).

}
//=======================================================================================


//@ModellingHypotheses{PlaneStrain, Axisymmetrical, Tridimensional};

//! Strain tensor $\epsilon$
@Gradient StrainStensor eto;
eto.setGlossaryName("Strain");

//! Stress tensor $\sigma$
@Flux StressStensor sig;
sig.setGlossaryName("Stress");

//! this is a boolean parameter which controls the verbosity.
//! Intended to use for debugging.
@Parameter psdVerbosity = 0;
psdVerbosity.setEntryName("psdVerbosity");

//! $K_i$ is the modulus of compressibility
@Parameter K_0 = 628.e6;
K_0.setEntryName("K_0");

//! $G_i$ is the shear modulus
@Parameter G_0 = 290.e6;
G_0.setEntryName("G_0");

//! $ne\in[0,1]$ is the non-linear elastic characteristic
//! $ne = 0$ corresponds to linear elasticity
@Parameter ne = 0.5;
ne.setEntryName("ne");

//! Friction angle at perfect plasticity (in degrees)
@Parameter phi_pp = -33;
phi_pp.setEntryName("phi_pp");

//! Characteristic State Line or dilatancy angle $\psi$ (in radians)
//! between th contracting field $p$ and dilating filed $q$:
//! $q = |p|\cdot \sin(\psi)$
@Parameter psi = -33;
psi.setEntryName("psi");

//! volumetric coefficient of plastic compressibility ($\beta > 0$)
@Parameter beta = 33;
beta.setEntryName("beta");

//! Initial Critical Pressure (or pre-consolidation stress) $p_{c0} < 0$
@Parameter p_c0 = -50.e3;
p_c0.setEntryName("p_c0");

//!  Volumetric monotonous hardening coefficient ($a_{m} > 0$)
@Parameter a_m = 0.0025;
a_m.setEntryName("a_m");

//! Deviatoric cyclic hardening coefficient ($a_{c} > 0$)
@Parameter a_c =  0.00001;
a_c.setEntryName("a_c");

//! $b\in[0,1]$ Shape coefficient
//! $b=0$ i.e Mohr-Coulomb and $b=1$  modified Cam-Clay
@Parameter b =  0.20 ;
b.setEntryName("b");

@Parameter alfa = 1.0;
alfa.setEntryName("alfa");

//! Elastic Domain Limit (deviatoric hardening coef $r_{ela} \in ]0,1]$ )
@Parameter r_ela = 0.03;
r_ela.setEntryName("r_ela");

//! Hysteretic Domain Limit (deviatoric hardening coef $r_{hys} \in ]0,1]$)
@Parameter r_hys =  0.04;
r_hys.setEntryName("r_hys");

//! Mobilized Domain Limit (deviatoric hardening coef $r_{mob} \in ]0,1]$)
@Parameter r_mob =  0.80;
r_mob.setEntryName("r_mob");

//! Volumetric monotonous hardening coefficient ($c_{m} > 0$)
@Parameter c_m = 0.004;
c_m.setEntryName("c_m");

//! Volumetric cylic hardening coefficient ($c_{c} > 0$)
@Parameter c_c = 0.002;
c_c.setEntryName("c_c");

//! Distance in e-lnp plane between Isotropic Consolidation and Critical State Lines
@Parameter d =  2.0;
d.setEntryName("d");

//! Elastic Domain Limit (volumetric hardening coef)
@Parameter dltela =  0.02;
dltela.setEntryName("dltela");

@Parameter xkimin = 0;
xkimin.setEntryName("xkimin");

@Parameter m = 1.0;
m.setEntryName("m");

//! integration reduction at group level
@Parameter facinc = 0.2;
facinc.setEntryName("facinc");

//! hypothesis variable of Hujeux group level
@Parameter iecoul = 1;
iecoul.setEntryName("iecoul");

//! integration variable max iteration at group level
@Parameter incmax = 50;
incmax.setEntryName("incmax");

@Parameter Kaux = 628.e6;
Kaux.setEntryName("Kaux");

@Parameter Gaux = 290.e6;
Gaux.setEntryName("Gaux");

//------------------- TO DO ------------------------------//
// @Evelyne: pref and indaux  seem to be orphan parameters
// I did not find them in the original Hujeux test can you
// confirm what is their use
//--------------------------------------------------------//

/*!Factor reduction on law integration increments */
//@Parameter pref = -1.e6;
//pref.setEntryName("pref");

/*!
Indicator for auxiliary tangent operator type
 *   0 = elastic (symmetric) => default
 *   1 = plastic (unsymmetric)
*/
@Parameter indaux = 0;
indaux.setEntryName("indaux");


@Private{

  void convert_stensor_to_mfront(StrainStensor& Sr){
    constexpr const auto icste = tfel::math::Cste<real>::isqrt2;
    std::cout << "  SQRT 2 " <<  icste << std::endl;
  }

  void print(std::string pp) const{
      std::cout << pp << std::endl;
  }

  void display(std::string pp, unsigned int aa) const{
      std::cout << pp <<  aa << std::endl;
  }

  void display(std::string pp, int aa) const{
      std::cout << pp <<  aa << std::endl;
  }

  void display(std::string pp, double aa) const{
      std::cout <<  std::setprecision(16)  << pp <<  aa << std::endl;
  }

  void display(std::string pp, long double aa) const{
      std::cout <<  std::setprecision(32) << pp <<  aa << std::endl;
  }

}

@Includes{
#include "stdafx.h"
#include "utils.h"
#include "hujeux.h"
}
@Sources {
#include "utils.cpp"
#include "hujeux.cpp"
}


/*
@StateVariable StrainStensor eel;
eel.setGlossaryName("ElasticStrain");

@StateVariable real epl;
epl.setGlossaryName("EquivalentPlasticStrain");


//! Monotonous hardening degrees ${r_m}={r_m1,r_m2,r_m3,r_m4}$
//! ${r_mk}_{k=1}^3$ - factors of mobilization for hardening in the plane pressure-shears
//  $r_m4$ hardening of the spherical mechanism of consolidation
@StateVariable real r_m[4];
raym.setEntryName("MonotonousHardeningDegrees");

//! Cyclic hardening degrees ${r_c} = {r_c1,r_c2,r_c3,r_c4}$
//! ${r_ck}_{k=1}^3$ - factors of mobilization for hisotropic and kinematical
//! mixed hardening in the plane pressure-shears
//  $r_c4$ isotropic and kinematical mixed hardening
@StateVariable real r_c[4];
rayc.setEntryName("CyclicHardeningDegrees");
*/

@StateVariable real hujxIsv[24];
hujxIsv.setEntryName("hujeuxInternalStateVariables");

/*
@LocalVariable Tensor2 Hujsig;
@LocalVariable Tensor2 Hujeps;
@LocalVariable Tensor2 Hujepsp;
@LocalVariable Tensor2 Hujdeps;
@LocalVariable Tensor2 Hujdsig;
*/

@StateVariable Stensor dSig;
@StateVariable Stensor depsP;

@StateVariable real InitStressH;

/*
@InitLocalVariables {
  if(!sig[0])
  {
    print("Entering InitLocalVariables for stress initilization ");

    for(int i = 0; i < 3; i++)
      sig[i] = p_c0;

    for(int i = 3; i < 6; i++)
      sig[i] = 0.;
  }

  if(psdVerbosity)
  {
    display("initial compressibility modulus       :: K_0    = ", K_0  );
    display("initial shear modulus                 :: G_0    = ", G_0  );
    display("nonlinear elastic characteristic      :: ne     = ", ne   );
    display("dilatancy angle  (in radians)         :: psi    = ", psi  );
    display("coef. of plastic compressibility      :: beta   = ", beta );
    display("initial critical pressure             :: p_c0   = ", p_c0 );
    display("volumetric monotonous hardening coef. :: a_m    = ", a_m  );
    display("deviatoric cyclic hardening coef.     :: a_c    = ", a_c  );
    display("vol. coef. of plastic compressibility :: beta   = ", beta );
    display("friction angle at perfect plasticity (in degrees) :: phi_pp = ", phi_pp);
  }
}
*/


/*
  Tensor2 Hujsig(Real3(p_c0, p_c0, p_c0), Real3::zero()), // effective stress tensor for current step
          Hujeps,	// strain tensor for current step
          Hujepsp,      // plastic strain tensor for current step
          Hujdeps,      // strain tensor increment
          Hujdsig;      // effective stress tensor increment
*/

/*!
 * We request Mfront to calculate the SymmetricTangentOperator
 * which is nothing but the stiffness matrix
 */
//@ProvidesSymmetricTangentOperator;


/*!
 * In this block the law is integrated
 *   1. compute the Lame parameters lambda, mu
 *   2. compute the stress state
 *   2. compute the stiffness matrix
 */
@Integrator{

  if(!sig[0])
  {
    print("Entering InitLocalVariables for stress initilization ");

    for(int i = 0; i < 3; i++)
      sig[i] = p_c0;

    for(int i = 3; i < 6; i++)
      sig[i] = 0.;
  }

//  static_cast<void>(smt); // remove compiler warning

  bool is_converge = true;                // Wrong Wrong correct MAB

  tfel::math::vector<double> mfront_parameters = {
    K_0    , G_0    , ne     , phi_pp , psi    ,
    beta   , p_c0   , a_m    , b      , a_c    ,
    alfa   , r_ela  , r_hys  , r_mob  , c_m    ,
    d      , c_c    , dltela , xkimin , m      ,
    facinc , iecoul , incmax , Kaux   , Gaux } ;

/*
if(oldMethod){
  for(int i = 0; i < 6; i++)
    Hujdeps.m_vec[i] =  deto[i];

  for(int i = 0; i < 6; i++)
    Hujeps.m_vec[i] = eto[i] + Hujdeps.m_vec[i];
}
*/

  behaviour_psd::HujeuxLaw psdSoilLaw;
  psdSoilLaw.init(mfront_parameters);

/*
if(oldMethod){
  for(int i = 0; i < 6; i++)
    Hujsig.m_vec[i] = sig[i];

  for(int i = 0; i < 6; i++)
    Hujdsig.m_vec[i] = dSig[i];

  for(int i = 0; i < 6; i++)
    Hujepsp.m_vec[i] = depsP[i];
}
*/


   if(!InitStressH)
   {
     display("First time iteration detected -----  ", InitStressH);

    //   psdSoilLaw.initState(hujxIsv,Hujsig); //old-Method//
       psdSoilLaw.initState(hujxIsv,sig);

     InitStressH = true;
   }

/*  //old-Method//
  if(psdVerbosity)
  {

   for(int i = 0; i < 6; i++)
      display("INITIAL  Hujsig.m_vec i ",Hujsig.m_vec[i]);
    for(int i = 0; i < 6; i++)
      display("INITIAL  Hujdsig.m_vec i ",Hujdsig.m_vec[i]);
    for(int i = 0; i < 6; i++)
      display("INITIAL  Hujeps.m_vec i ",Hujeps.m_vec[i]);
    for(int i = 0; i < 6; i++)
      display("INITIAL  Hujdeps.m_vec i ",Hujdeps.m_vec[i]);
    for(int i = 0; i < 6; i++)
      display("INITIAL  Hujepsp.m_vec i ",Hujepsp.m_vec[i]);
    for(int i = 0; i < 24; i++)
      display("INITIAL  hujxIsv[i] ",hujxIsv[i]);
  }
*/


    psdSoilLaw.ComputeStress( hujxIsv, sig, eto, depsP, dSig, deto, is_converge );

/*  //old-Method//

  psdSoilLaw.ComputeStress( hujxIsv, Hujsig, Hujeps, Hujepsp, Hujdsig, Hujdeps, is_converge ); //old-Method

  for(int i = 0; i < 6; i++)
    sig[i] = Hujsig.m_vec[i];

  for(int i = 0; i < 6; i++)
    dSig[i] = Hujdsig.m_vec[i];

  for(int i = 0; i < 6; i++)
    depsP[i] = Hujepsp.m_vec[i];

  for(int i = 0; i < 6; i++)
    eto[i] = Hujeps.m_vec[i];

  if(psdVerbosity)
  {
   for(int i = 0; i < 6; i++)
     display("FINAL  Hujsig.m_vec i ",Hujsig.m_vec[i]);
    for(int i = 0; i < 6; i++)
      display("FINAL  Hujdsig.m_vec i ",Hujdsig.m_vec[i]);
    for(int i = 0; i < 6; i++)
      display("FINAL  Hujeps.m_vec i ",Hujeps.m_vec[i]);
    for(int i = 0; i < 6; i++)
      display("FINAL  Hujdeps.m_vec i ",Hujdeps.m_vec[i]);
    for(int i = 0; i < 6; i++)
      display("FINAL  Hujepsp.m_vec i ",Hujepsp.m_vec[i]);
    for(int i = 0; i < 24; i++)
      display("FINAL  hujxIsv[i] ",hujxIsv[i]);
  }
*/

  //const stress lambda = computeLambda(E,nu);
  //const stress mu     = computeMu(,nu);
  //sig = 10*trace(eto+deto)*StrainStensor::Id()+2*20*(eto+deto);
  //if(computeTangentOperator_){
  //  Dt = lambda*Stensor4::IxI()+2*mu*Stensor4::Id();
  //}
}
