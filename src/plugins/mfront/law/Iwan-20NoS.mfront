@DSL Implicit;
@Behaviour Iwan;
@Author Vinicius Alves Thomas Helfer Reine Fares;
@Description {
  Iwan model for cyclic behaviour of soils.
  Here we implement the first algorithm
  proposed by Simo and Hughes
  
  Simo , Juan C and Hughes , Thomas J. R
  Computational inelasticity
  1998 , Springer
  isbn: 0-387-97520-9 978-0-387-97520-7
}

@Brick StandardElasticity;

@Epsilon 1.e-16;
@Theta 1.;
@IterMax 200;

// Maximum Number of hardening surfaces Ns = 20




@MaterialProperty stress young;
young.setGlossaryName("YoungModulus");
@MaterialProperty real   nu;
nu.setGlossaryName("PoissonRatio");

// Size of kinematical surfaces
// Number of hardening surfaces
// @MaterialProperty real Ns;
// Ns.setGlossaryName("NumberofSpring");


@MaterialProperty real Ns ;
Ns.setEntryName("NumberofSpring") ;
@MaterialProperty stress C[20];
C.setEntryName("YielsurfacestressCi") ;
@MaterialProperty stress Y[20];
Y.setEntryName("YielsurfacestrainYi") ;

// Exemple
// ----------------------- START---------------------------------------------------------------------------
// @ElasticMaterialProperties{614930000.0, 3.71000000E-01};
// @IntegerConstant Ns = 16;
// @Parameter stress C[Ns] = {1438707420, 31390142724, 38213126183, 12058438512, 6415920460, 4779863112, 
// 6160771598, 9332518493, 1518307923, 900683489.3, 620762077.8, 181090675.9, 
// 134905475.6, 75387120.03, 39561849.73, 39229506.65, 0., 0., 0.,0. };
// @AuxiliaryStateVariable stress Y[100] ;
// Y.setGlossaryName("Stessname2") ;
//constant, obtained from laboratory tests, that characterizes the nth yield surface
// @Parameter stress Y[Ns] = {340005.5091, 420308.5133, 524405.5834, 653604.7237, 1647053.671, 2520327.797, 
// 4384366.063, 5203073.539, 8131982.302, 11264333.18, 13251691.55, 16720370.49, 
// 19253276.75, 20620902.16, 22768742.08, 21428992.9, 0., 0., 0.,0. };
// ----------------------- END ---------------------------------------------------------------------------

// Auxiliary state variable
@AuxiliaryStateVariable strain p[20];
p.setGlossaryName("EquivalentPlasticStrain");
@AuxiliaryStateVariable Stensor X[20];
X.setEntryName("BackStress");



@LocalVariable strain dp[20];

// Plastic flow tensor
@LocalVariable Stensor n[20];
// status of each plastic system
@LocalVariable bool status[20];
@LocalVariable stress lambda;
@LocalVariable stress mu;


@InitLocalVariables{
  lambda = computeLambda(young,nu);
  mu     = computeMu(young,nu);
}

@Predictor {
  const auto sigel = computeElasticPrediction();
  for (unsigned short i = 0; i != Ns; ++i) {
    status[i] = sigmaeq(sigel - X[i]) > Y[i];
  }
  deel = (trace(deto) / 3) * StrainStensor::Id();
}

@Integrator {
  const real eps = 1e-12;
  for (unsigned short i = 0; i != Ns; ++i) {
    if (!status[i]) {
      continue;
    };
    const auto seq = sigmaeq(sig - X[i]);
    const auto iseq = 1 / max(seq , eps * young);
    dp[i] = 2 * (seq - Y[i]) / (3 * theta * C[i]);
    n[i] = 3 * deviator(sig - X[i]) * (iseq / 2);
    feel += dp[i] * n[i];
    dfeel_ddeel += 2 * mu * theta *
                   (theta * dp[i] * iseq * (Stensor4::M() - (n[i] ^ n[i])) +
                    2 / (3 * theta * C[i]) * (n[i] ^ n[i]));
  }

}

@AdditionalConvergenceChecks {
  if (converged) {
    // checking status consistency
    for (unsigned short i = 0; i != Ns; ++i) {
      if (status[i]) {
        if (dp[i] < epsilon) {
          // desactivating this system
          converged = status[i] = false;
        }
      } else {
        if (sigmaeq(sig - X[i]) > Y[i] + young * epsilon) {
          converged = false;
          status[i] = true;
        }
      }
    }
  }
}
 
@UpdateAuxiliaryStateVariables {
  for (unsigned short i = 0; i != Ns; ++i) {
    if (status[i]) {
      p[i] += dp[i];
      X[i] += C[i] * dp[i] * n[i];
    }
  }
}
